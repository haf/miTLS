(*
 * Copyright (c) 2012--2013 MSR-INRIA Joint Center. All rights reserved.
 * 
 * This code is distributed under the terms for the CeCILL-B (version 1)
 * license.
 * 
 * You should have received a copy of the CeCILL-B (version 1) license
 * along with this program.  If not, see:
 * 
 *   http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 *)

module Sig

open Bytes
open TLSConstants

(* TLS uses three signatures algorithms, together with hash algorithm.
   We verify TLS security relative to those *combinations* of algorithms
   that provide CMA-security, as specified in this interface.
   However, none of them are CMA-secure in the standard model under an
   assumption weaker than "This scheme is secure".

   This interface is adapted from the one described in CCS'11:

       Cedric Fournet, Markulf Kohlweiss, Pierre-Yves Strub: Modular
       code-based cryptographic verification. ACM Conference on Computer
       and Communications Security 2011: 341-350

   Its implementation is trusted, not verified. *)

(*********************** Cryptographic agility ****************************

   note that the same key may be used with different hashes.
   so we require some joint security assumption for them

   TLS 1.2 provides explicit support for it:
   [1.2] - Substantial cleanup to the client's and server's ability to
           specify which hash and signature algorithms they will accept.
           Note that this also relaxes some of the constraints on signature
           and hash algorithms from previous versions of TLS.
***************************************************************************)

// implements SignatureAndHashAlgorithm, with fewer values for hashAlg

type alg   = sigHashAlg

type text = bytes
type (;a:alg) sigv = bytes

  // with TLS 1.2, this explicitly contains a; see DigitallySigned struct

// Summary of the extension logic for the client:
// - specific to TLS 1.2
// - cs indicates sigAlg but not hashAlg, but "this is historical"
// - extension indicates supported algs (not necessarily following the cs)
// - no extension == client supports exactly the default alg

// let defaultAlg cs =
//   let a =
//     match cs with
//     | RSA | DH_RSA | DHE_RSA | RSA_PSK (* | ECDH_RSA | ECDHE_RSA *) -> RSA
//     | DH_DSS | DHE_DSS                                              -> DSA
//     | ECDH_ECDSA | ECDHE_ECDSA                                      -> ECDSA in
//   (a, SHA1)

//********************** Ideal Functionality for Signing ***********************
private type (;a:alg) pkey = {pkey : CoreSig.sigpkey * hashAlg }
//#begin-abstraction
private type (;a:alg) skey = {skey: CoreSig.sigskey * hashAlg; pub: (;a) pkey}
//#end-abstraction

function val PK: 'a -> 'b // a:alg * (;a)skey -> vkey
private definition !sk. PK(sk) = sk.pub

predicate Msg of a:alg * (;a)pkey * text
predicate type pred = Honest of a:alg * (;a) pkey
predicate Strong of alg
private definition !a. Strong(a) <=> (a = (SA_DSA,SHA384))

val gen:     a:alg -> pk:(;a) pkey * sk:(;a) skey { pk = PK(sk) }
val sign:    a:alg -> sk:(;a) skey -> t:text{Msg(a,PK(sk),t)} -> (;a) sigv
val verify:  a:alg -> pk:(;a) pkey -> t:text -> m:(;a) sigv ->
  b:bool {(b=true /\ Strong(a) /\ Honest(a,pk)) => Msg(a,pk,t)}

type honest_entry = (a:alg * sk:(;a)skey * pk:(;a)pkey{Honest(a,pk) /\ pk = PK(sk)})
private val honest_log: (honest_entry list) ref
private val has_pk: a:alg -> pk:(;a)pkey ->
          (honest_entry list) -> b:bool{(b = true => Honest(a,pk))}
(*
private val find_pk: a:alg -> sk:(;a)skey -> (pk:(;a)pkey{pk = PK(sk) /\ Honest(a,pk)}) option
*)
val pk_of: a:alg -> sk:(;a) skey -> pk:(;a) pkey{pk = PK(sk)}
val honest: a:alg -> pk: (;a) pkey -> b:bool{(b = true /\ Honest(a,pk)) \/ (b=false /\ not Honest(a,pk))}
val strong: a:alg -> b:bool{(b = true /\ Strong(a)) \/ (b = false /\ not Strong(a))}

private val consHonestLog: a:alg -> sk:(;a)skey -> pk:(;a) pkey{Honest(a,pk) /\ pk = PK(sk)} -> (honest_entry list) -> honest_entry list

type entry = (a:alg * pk:(;a) pkey * t:text){ Msg(a,pk,t) }
private val log: entry list ref
private val consLog: a:alg -> pk:(;a) pkey -> t:text {Msg(a,pk,t)} -> entry list -> entry list
private val has_mac: a:alg -> pk:(;a) pkey -> t:text -> entry list -> b:bool{b = true => Msg(a,pk,t)}

val coerce:  a:alg -> p:(;a) pkey{not Honest(a,p)} -> CoreSig.sigskey -> s:(;a)skey{p = PK(s)}
val leak:    a:alg -> s:(;a) skey{not Honest(a,PK(s))} -> CoreSig.sigskey

private val create_pkey: a:alg -> CoreSig.sigpkey -> (;a)pkey
