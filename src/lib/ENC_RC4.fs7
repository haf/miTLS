(*
 * Copyright (c) 2012--2013 MSR-INRIA Joint Center. All rights reserved.
 * 
 * This code is distributed under the terms for the CeCILL-B (version 1)
 * license.
 * 
 * You should have received a copy of the CeCILL-B (version 1) license
 * along with this program.  If not, see:
 * 
 *   http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 *)

module ENC_RC4

// ideal interface, in case we assume RC4 is CPA-secure (at least as used in TLS);
// this module is multi-instance, but unconditionally secure---it treats Encode.plain entirely abstractly.
// It is used only at Safe indexes.

open Bytes
open Encode
open TLSConstants
open TLSInfo
open Error
open Range

type cipher = b:bytes{Length(b) <= max_TLSCipher_fragment_length}
type keyrepr = b:bytes{Length(b) = EncKeySize(Stream_RC4_128) (* aka 16 *) }
private type (;e:epoch) state = {n:nat; u:bool; k:keyrepr; s:CoreCiphers.rc4engine }

type rc4epoch = e:succEpoch
  {CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(Stream_RC4_128,mac)}

predicate val Encryptor: (e:epoch * s:(;e) state)-> bool
function val SeqN:       (e:epoch * s:(;e) state) -> nat

private definition !e,s. Encryptor(e,s) = s.u
private definition !e,s. SeqN(e,s) = s.n

// to be moved elsewere!
function val ADseqN: (e:epoch * ad:(;e) LHAEPlain.adata) -> nat

type (;e:epoch) encryptor = s:(;e) state { Encryptor(e,s)=true }
type (;e:epoch) decryptor = s:(;e) state { Encryptor(e,s)=false }

// in this module, we take advantage that widening is the identity function]

// in this module, we use sequence numbers, rather than abstract StateIDs.
// so we'll have to define StateID(e,s) = s.n

val GEN: e:epoch -> (s:(;e) encryptor {SeqN(e,s)=0})
                  * (s:(;e) decryptor {SeqN(e,s)=0})

// in this module,
// - ad is an abstract state index, from which we extract our sequence number
// - rg is a point interval, function of (Length c)
type event = ENCrypted of
  e:epoch * ad:(;e)LHAEPlain.adata * c:cipher * p:(;e,ad,CipherRangeClass(e,Length(c))) plain

// We encrypt at most once at every index (e,ad), hence ENCrypted is injective
private assume !e,ad,c,p0,p1.
  (ENCrypted(e,ad,c,p0) /\ ENCrypted(e,ad,c,p1)) => p0 = p1

val ENC: e:rc4epoch -> s:(;e) encryptor ->
  ad:(;e)LHAEPlain.adata{ SeqN(e,s) = ADseqN(e,ad) } -> r:range -> p:(;e,ad,r)plain ->
  ( (s': (;e) encryptor{ SeqN(e,s')= SeqN(e,s)+1}) *
    (c : cipher{ ENCrypted(e,ad,c,p) /\ Length(c)=TargetLength(e,r)}) )

val DEC: e:rc4epoch -> s:(;e) decryptor ->
  ad:(;e)LHAEPlain.adata{ SeqN(e,s) = ADseqN(e,ad) } ->
  c:cipher { Length(c) >= MinTlen(e) /\ ?p. ENCrypted(e,ad,c,p) } ->
  ( (s': (;e) decryptor{SeqN(e,s') = SeqN(e,s)+1}) *
    (p : (;e,ad,CipherRangeClass(e,Length(c))) plain{ Safe(e) => !p'. ENCrypted(e,ad,c,p') => p=p'}))

val LEAK:    e:rc4epoch { not(Safe(e)) } -> (;e)state -> keyrepr
val COERCEe: e:rc4epoch { not(Safe(e)) } -> keyrepr -> s:(;e)encryptor{SeqN(e,s)=0}
val COERCEd: e:rc4epoch { not(Safe(e)) } -> keyrepr -> s:(;e)decryptor{SeqN(e,s)=0}

private ask !e,t.
  CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(Stream_RC4_128,mac)
  => PlainLength(e,t) = t
private ask !e,r.
  CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(Stream_RC4_128,mac)
  =>
  CipherRangeClass(e,TargetLength(e,r)) = r
private ask !e,r.
  CipherRangeClass(e,r) <= max_TLSCipher_fragment_length

private val rc4: e:rc4epoch -> s:(;e) state -> b:bytes -> s':(;e) state * b':bytes
  { Length(b') = Length(b) /\ s'.u = s.u /\ s'.n = s.n + 1 }

private val encryptor: e:epoch -> k:keyrepr -> s:(;e) encryptor{ SeqN(e,s)=0 }
private val decryptor: e:epoch -> k:keyrepr -> s:(;e) decryptor{ SeqN(e,s)=0 }

private type entry =
  (e:epoch * ad:(;e)LHAEPlain.adata * c:cipher * p:(;e,ad,CipherRangeClass(e,Length(c)))plain ) { ENCrypted(e,ad,c,p) }

private val log: entry list ref
private val cfind: e:epoch -> ad:(;e)LHAEPlain.adata -> c:cipher -> xs: entry list ->
  p:(;e,ad,CipherRangeClass(e,Length(c))) Encode.plain {ENCrypted(e,ad,c,p)}
