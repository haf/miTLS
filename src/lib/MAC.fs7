(*
 * Copyright (c) 2012--2013 MSR-INRIA Joint Center. All rights reserved.
 * 
 * This code is distributed under the terms for the CeCILL-B (version 1)
 * license.
 * 
 * You should have received a copy of the CeCILL-B (version 1) license
 * along with this program.  If not, see:
 * 
 *   http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 *)

module MAC

open Bytes
open TLSConstants
open TLSInfo

(* refined, agile, ideal interface for indexed MACs
   resistant to existential forgery against chosen message attacks (INT-CMA).

  This module depends on

   - a datatype of MAC algorithms (TLSConstants.MAC_alg)
   - an abstract type of indexes (TLSInfo.epoch)
   - a function from indexes to MAC algorithms (macAlg_of_epoch) and its logical spec.
   - functions from MAC algorithms to their key-lengths and tag-lengths, and their logical specs.
   - an function from indexes to booleans that indicates the safe indexes (safeMAC) and its logical spec;
     (this function is used only #if ideal)
   - an abstract predicate on indexes and message (Msg),
     specifying the logical property authenticated by safe MACs.

   and the following assumptions:

   - we generate (or coerce) at most one key per index.
   - if an index is Auth, then its algorithm is computationally strong (INT-CMA).

   Notes: - this interface deals with CMA, not the joint CTXT assumption (where we rely on PRF)
          - this multiplexing similarly applies to any keyed functionality.
		  - concretely, we would get a bound depending on the quantitative usage of each strong algorithm
		  - pragmatically, we may e.g. assume INT-CMA for both variants of SHA2, but not for MD5 or SHA.
		  - so far we do attempt to prove that the ad hoc constructions of SSL_3p0 are strong.

   We typecheck an ideal variant of this module,
   with an additional indirection for every call to HMAC with an Auth index via
   a series of (standard, non-agile) MAC$a interfaces that specify that algorithm $a is INT-CMA.
   where $a ranges over the subset of MAC algorithms of TLS for which we assume are INT-CMA.

   The proof that MAC securely implements MAC.fs7 (up to computational indistinguishability)
   goes as follows. Formally, it is parametric in the number of MAC algorithms that are INT-CMA,
   so we need to typecheck MAC.fs for each such number, but this is very uniform; we do it for 2.

   (1) When using the concrete implementations of MAC$a,
       we easily check that toggling the #ideal flag in MAC.fs does not change its behaviour,
	   (e.g. by inlining MAC$a.fs within MAC.fs) since both variants make the same calls to HMAC.

   (2) By MAC.tc7, and since no other module calls any MAC$a,
       we have (complete) abstraction for MAC$a.key, so
       we apply their INT-CMA assumptions (up to computational indistinguishability),
       setting the #ideal flag in each MAC$a.fs implementation.

   (3) By MAC$a.tc7, we typecheck that the ideal variant of MAC$a now implements MAC$a.fs7

   (4) By MAC.tc7, we conclude that the ideal variant of MAC now implements MAC.fs7

   Our concrete core algorithms are implemented by HMAC,
   after partial application of the algorithm name.
   (we keep using a single HMAC module just for convenience, with constants as their first "a" parameters) *)

type (;ki:succEpoch) keyrepr = k:bytes {Length(k) = MacSize(CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version)) }
type (;ki:succEpoch) tag     = m:bytes {Length(m) = MacSize(CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version))}

// Our type of keys has a separate constructor for each strong MAC algorithm,
// so that each of their key types (MAC_SHA256.key) can be kept abstract at every Auth index when #ideal.
// plus a default constructor for all other keys, concretely represented as fixed-length bytes.
// (thus, when not #ideal, all keys are KeyNoAuth and the other constructors are not used.)
private type (;ki:succEpoch) key =
  | KeyNoAuth of (k:(;ki) keyrepr { not(Auth(ki)) })
  | Key_SHA256 of (k:(;ki) MAC_SHA256.key
    { Auth(ki) /\
	  MAC_SHA256.a = CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) })
  | Key_SHA1 of (k:(;ki) MAC_SHA1.key
    { Auth(ki) /\
	  MAC_SHA1.a = CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) })

// this assumption records the list of concrete MAC algorithms
// assumed to be INT-CMA (in this instance, just MAC_SHA256.a is)
private assume
  !ki. Auth(ki) => (  CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = MAC_SHA256.a
                   \/ CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = MAC_SHA1.a )

ask !e,alg. Auth(e) /\ alg = CipherSuiteMACAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) =>
	(alg = MAC_SHA256.a \/ alg = MAC_SHA1.a)

type text = bytes
predicate val Msg: epoch * text -> bool

// We define the Msg predicate of each MAC_SHA256 as follows,
// logically multiplexing them to the Msg predicate of MAC (to be defined in turn by users of MAC)
private definition
  !ki,t. MAC_SHA256.Msg(ki,t) <=>
      (Msg(ki,t) /\
	   Auth(ki) /\
	   MAC_SHA256.a = CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version))
private definition
  !ki,t. MAC_SHA1.Msg(ki,t) <=>
      (Msg(ki,t) /\
	   Auth(ki) /\
	   MAC_SHA1.a = CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version))

val Mac:    ki:succEpoch -> k:(;ki) key -> t:text{Msg(ki,t)} -> m:(;ki) tag
val Verify: ki:succEpoch -> k:(;ki) key -> t:text -> m:(;ki) tag -> b:bool{ (b=true /\ Auth(ki)) => Msg(ki,t) }

val GEN:    ki:succEpoch -> (;ki) key
val LEAK:   ki:succEpoch {not(Auth(ki))} -> (;ki)key -> (;ki)keyrepr
val COERCE: ki:succEpoch {not(Auth(ki))} -> (;ki)keyrepr -> (;ki)key

(*
// typing the log for an ideal functionality that
// directly specifies the security of MAC (not used anymore)
private type entry = (ki:epoch * t:text * (;ki)tag){Msg(ki,t)}
private val log: entry list ref
private val tmem: ki:epoch -> t:text -> entry list -> b:bool{ b = true => Msg(ki,t) }
*)
