(*
 * Copyright (c) 2012--2013 MSR-INRIA Joint Center. All rights reserved.
 * 
 * This code is distributed under the terms for the CeCILL-B (version 1)
 * license.
 * 
 * You should have received a copy of the CeCILL-B (version 1) license
 * along with this program.  If not, see:
 * 
 *   http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 *)

module Handshake

open Bytes
open Error
open TLSInfo
open Range
open StatefulLHAE
open TLSConstants
open TLSExtensions

(* Message Predicates *)
type HandshakeType =
    | HT_hello_request
    | HT_client_hello
    | HT_server_hello
    | HT_certificate
    | HT_server_key_exchange
    | HT_certificate_request
    | HT_server_hello_done
    | HT_certificate_verify
    | HT_client_key_exchange
    | HT_finished

function val HTBytes: HandshakeType -> bytes

private definition
    HTBytes(HT_hello_request      ) = [|  0uy |] /\
    HTBytes(HT_client_hello       ) = [|  1uy |] /\
    HTBytes(HT_server_hello       ) = [|  2uy |] /\
    HTBytes(HT_certificate        ) = [| 11uy |] /\
    HTBytes(HT_server_key_exchange) = [| 12uy |] /\
    HTBytes(HT_certificate_request) = [| 13uy |] /\
    HTBytes(HT_server_hello_done  ) = [| 14uy |] /\
    HTBytes(HT_certificate_verify ) = [| 15uy |] /\
    HTBytes(HT_client_key_exchange) = [| 16uy |] /\
    HTBytes(HT_finished           ) = [| 20uy |]

val htBytes: ht:HandshakeType -> b:bytes{b=HTBytes(ht)}
val parseHt: b:bytes -> (ht:HandshakeType{b=HTBytes(ht)}) Result

function val MessageBytes: HandshakeType * bytes -> bytes
private definition !ht,b. MessageBytes(ht,b) = HTBytes(ht) @| VLBytes(3,b)
val messageBytes: ht:HandshakeType -> x:bytes -> m:bytes{m = MessageBytes(ht,x)}
val parseMessage: buf:bytes -> ((rem:bytes * ht:HandshakeType * x:bytes * to_log:bytes)
				{buf = to_log @| rem /\ to_log = MessageBytes(ht,x)}) option Result

// Next predicate to make sure we can make fragments
predicate type unsafe = Unsafe of epoch
private definition !ki. Unsafe(ki) <=> not Auth(ki)
val makeFragment: ki:epoch -> b:bytes -> (r:range * (;ki,HSFragment.EmptyStream(ki),r) HSFragment.plain * bytes)

(* verify data authenticated by the Finished messages *)
type log = bytes         (* message payloads so far, to be eventually authenticated *)
type cVerifyData = bytes (* ClientFinished payload *)
type sVerifyData = bytes (* ServerFinished payload *)

// For each Handshake message x, we have:
// XMsg   : a logical specification of its wire format
// xBytes : a formatting function
// parseX : a parsing function (returning a Result, as parsing may fail)

function val ClientHelloMsg: (ProtocolVersion * random * sessionID * cipherSuites * Compression list * bytes) -> bytes
definition !cv,clRdm,sid,cls,cm,ext,b.
    ClientHelloMsg(cv,clRdm,sid,cls,cm,ext) =
		MessageBytes(HT_client_hello,
            (VersionBytes(cv) @|
             clRdm @|
             VLBytes(1,sid) @|
             VLBytes(2,CipherSuitesBytes(cls)) @|
             VLBytes(1,CompressionsBytes(cm)) @|
             ext)
		)

val clientHelloBytes: c:config -> cr:random -> sid:sessionID -> ext:bytes -> m:bytes{m = ClientHelloMsg(c.maxVer,cr,sid,c.ciphersuites,c.compressions,ext)}
val parseClientHello: m:bytes ->
	( pv:ProtocolVersion * cr:crand * sid:sessionID * cs:cipherSuites * cm:Compression list * ext:bytes
	  {?cs',cm'. MessageBytes(HT_client_hello,m) = ClientHelloMsg(pv,cr,sid,cs',cm',ext)
              /\ ContainsCipherSuites(cs',cs) /\ ContainsCompressions(cm',cm)}) Result

function val ServerHelloMsg: (ProtocolVersion * random * sessionID * cipherSuite * Compression * bytes) -> bytes
private definition !pv,sr,sid,cs,cm,ext.
	ServerHelloMsg(pv,sr,sid,cs,cm,ext) =
		MessageBytes(HT_server_hello,
			(VersionBytes(pv) @|
			 sr @|
			 VLBytes(1,sid) @|
			 CipherSuiteBytes(cs) @|
			 CompressionBytes(cm) @|
			 ext)
		)

function val  SessionHelloParams: SessionInfo * unit -> (ProtocolVersion * cipherSuite * Compression)
private definition !si.
 SessionHelloParams(si,()) = (si.protocol_version,si.cipher_suite,si.compression)

val serverHelloBytes: si:SessionInfo -> sr:random -> ext:bytes ->
	b:bytes{b = ServerHelloMsg(si.protocol_version,sr,si.sessionID,si.cipher_suite,
							   si.compression,ext)}
val parseServerHello: b:bytes ->
	((pv:ProtocolVersion * sr:random * sid:sessionID * cs:cipherSuite * cm:Compression * ext:bytes)
	 {MessageBytes(HT_server_hello,b) = ServerHelloMsg(pv,sr,sid,cs,cm,ext)})
	Result

val helloRequestBytes: b:bytes{b=MessageBytes(HT_hello_request,[||])}
val CCSBytes: b:bytes{b=[|1uy|]}

function val ServerHelloDoneMsg: bytes -> bytes
private definition !x. ServerHelloDoneMsg(x) = MessageBytes(HT_server_hello_done,[||])

val serverHelloDoneBytes: b:bytes{b=ServerHelloDoneMsg([||])}

function val CertificateMsg: Cert.chain -> bytes
private definition !cl. CertificateMsg(cl) = MessageBytes(HT_certificate,VLBytes(3,Cert.CertificateListBytes(cl)))

val serverCertificateBytes: cl:Cert.chain ->
	b:bytes{b = CertificateMsg(cl)}

val clientCertificateBytes: clo: (Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
	b:bytes{
		( clo = None /\ b = CertificateMsg([]) ) \/
		( ?cl,a',b'. clo = Some((cl,a',b')) /\ b = CertificateMsg(cl)
		)}

val parseClientOrServerCertificate: b:bytes ->
	(bl:Cert.chain{
	  MessageBytes(HT_certificate,b) = CertificateMsg(bl)
	}) Result

function val CertificateRequestTLS12: certType list * Sig.alg list * string list -> bytes
private definition !ct,sa,dn.
	CertificateRequestTLS12(ct,sa,dn) =
		MessageBytes(HT_certificate_request,
		  VLBytes(1,CertTypesBytes(ct)) @|
		  VLBytes(2,SigHashAlgsBytes(sa)) @|
		  VLBytes(2,DistinguishedNamesBytes(dn)))
function val CertificateRequestTLS: certType list * string list -> bytes
private definition !ct,dn.
	CertificateRequestTLS(ct,dn) =
		MessageBytes(HT_certificate_request,
		    VLBytes(1,CertTypesBytes(ct)) @| [||] @|
		    VLBytes(2,DistinguishedNamesBytes(dn)))
function val CertificateRequestMsg: ProtocolVersion * certType list * Sig.alg list * string list -> bytes
private definition !pv,ct,sa,dn.
	(pv = TLS_1p2 => CertificateRequestMsg(pv,ct,sa,dn) = CertificateRequestTLS12(ct,sa,dn)) /\
	((pv = TLS_1p1 \/ pv = TLS_1p0 \/ pv = SSL_3p0) => CertificateRequestMsg(pv,ct,sa,dn) = CertificateRequestTLS(ct,dn))

val sigHashAlgBytesVersion: pv:ProtocolVersion -> cs:cipherSuite ->
	b:bytes{(pv = TLS_1p2 => b=VLBytes(2,SigHashAlgsBytes(DefaultSigHashAlgs(pv,cs)))) /\
			((pv = TLS_1p1 \/ pv = TLS_1p0 \/ pv = SSL_3p0) =>
				b = [||])}

val parseSigHashAlgVersion: pv:ProtocolVersion -> b:bytes ->
	((a:(Sig.alg list) * r:bytes){
		(pv = TLS_1p2 =>
			(b = VLBytes(2,SigHashAlgsBytes(a)) @| r)
		) /\
		((pv = TLS_1p1 \/ pv = TLS_1p0 \/ pv = SSL_3p0) =>
			a = [] /\  r=b)
	}) Result

val certificateRequestBytes: sign:bool -> cs:cipherSuite -> pv:ProtocolVersion ->
	b:bytes{b = CertificateRequestMsg(pv,DefaultCertTypes(sign,cs),DefaultSigHashAlgs(pv,cs),[])}

val parseCertificateRequest: pv:ProtocolVersion -> b:bytes ->
	((ctl:certType list * al:(Sig.alg list) * sl:string list){
		MessageBytes(HT_certificate_request,b) = CertificateRequestMsg(pv,ctl,al,sl)})	 Result

function val ClientKeyExchangeMsg_RSA: pv:ProtocolVersion * bytes -> bytes
private definition !pv,encpms,b.
       ((pv = TLS_1p2 \/ pv = TLS_1p1 \/ pv = TLS_1p0) => ClientKeyExchangeMsg_RSA(pv,encpms) = MessageBytes(HT_client_key_exchange,VLBytes(2,encpms))) /\
	(pv = SSL_3p0 => ClientKeyExchangeMsg_RSA(pv,encpms) = MessageBytes(HT_client_key_exchange,encpms))

val encpmsBytesVersion: pv:ProtocolVersion -> encpms:bytes ->
	b:bytes{(pv = SSL_3p0 => b=encpms) /\
		((pv = TLS_1p0 \/ pv = TLS_1p1 \/ pv = TLS_1p2) => b=VLBytes(2,encpms))}

val parseEncpmsVersion: pv:ProtocolVersion -> b:bytes ->
	(encpms:bytes{
		(pv = SSL_3p0 => b=encpms) /\
		((pv = TLS_1p0 \/ pv = TLS_1p1 \/ pv = TLS_1p2) => b = VLBytes(2,encpms))
	}) Result

// For the next two functions, the returned encpms is a ghost variable used to
// avoid an existential.
val clientKEXBytes_RSA: si:SessionInfo -> c:config ->
	((b:bytes * pmsdata:TLSInfo.pmsData * pms:(;Cert.RSAPKCert(si.serverID),c.maxVer)CRE.rsapms){
           ?encpms. pmsdata = RSAPMS(Cert.RSAPKCert(si.serverID),c.maxVer,encpms) /\
		b=ClientKeyExchangeMsg_RSA(si.protocol_version,encpms)
		}) Result
val parseClientKEX_RSA: si:SessionInfo -> RSAKey.sk -> pv:ProtocolVersion -> config -> b:bytes ->
	((pmsdata:TLSInfo.pmsData *
         (;Cert.RSAPKCert(si.serverID),pv)CRE.rsapms){
           ?encpms. pmsdata = RSAPMS(Cert.RSAPKCert(si.serverID),pv,encpms) /\
     	            ClientKeyExchangeMsg_RSA(si.protocol_version,encpms) = MessageBytes(HT_client_key_exchange,b)
	}) Result

function val ClientKeyExchangeMsg_DHE: bytes -> bytes
private definition !b.
	ClientKeyExchangeMsg_DHE(b) =
		MessageBytes(HT_client_key_exchange,
			VLBytes(2,b))

val clientKEXExplicitBytes_DH: gx:bytes ->
	b:bytes{b = ClientKeyExchangeMsg_DHE(gx)}
val parseClientKEXExplicit_DH: p:DHGroup.p -> b:bytes ->
	(gx:(;p)DHGroup.elt{
		MessageBytes(HT_client_key_exchange,b) =
                ClientKeyExchangeMsg_DHE(gx)
	}) Result
val clientKEXImplicitBytes_DH: bytes
val parseClientKEXImplicit_DH: bytes -> unit Result

(* Digitally signed and DHE parameters *)
function val DigitallySignedBytes: Sig.alg * bytes * ProtocolVersion -> bytes
private definition !a,p,pv.
	(pv = TLS_1p2 => DigitallySignedBytes(a,p,pv) = SigHashAlgBytes(a) @| VLBytes(2,p)) /\
	( (pv = TLS_1p1 \/ pv = TLS_1p0 \/ pv = SSL_3p0) => DigitallySignedBytes(a,p,pv) = VLBytes(2,p))

val digitallySignedBytes: a:Sig.alg -> p:bytes -> pv:ProtocolVersion ->
	b:bytes{b = DigitallySignedBytes(a,p,pv)}
val parseDigitallySigned: al:Sig.alg list -> b:bytes -> pv:ProtocolVersion ->
	((a:Sig.alg * p:bytes){
		b = DigitallySignedBytes(a,p,pv)
		// /\ SigHashAlgContains(al,a)
	}) Result

function val DHEParamBytes: bytes * bytes * bytes -> bytes
private definition !p,g,y.
	DHEParamBytes(p,g,y) =
		VLBytes(2,p) @|
		VLBytes(2,g) @|
		VLBytes(2,y)
val dheParamBytes: p:bytes -> g:bytes -> y:bytes ->
	b:bytes{b = DHEParamBytes(p,g,y)}
val parseDHEParams: b:bytes ->
 (p:DHGroup.p * g:(;p)DHGroup.elt * y:(;p)DHGroup.elt * rem:bytes {
	b = (DHEParamBytes(p,g,y) @| rem)
 }) Result

function val ServerKeyExchangeMsg_DHE:  ProtocolVersion * p:bytes * g:bytes * y:bytes * Sig.alg * sign:bytes-> bytes
private definition !pv,p,g,y,a,sign.
	ServerKeyExchangeMsg_DHE(pv,p,g,y,a,sign) =
		MessageBytes(HT_server_key_exchange,
			DHEParamBytes(p,g,y) @| DigitallySignedBytes(a,sign,pv))

val serverKeyExchangeBytes_DHE: dheb:bytes{?p,g,y. dheb = DHEParamBytes(p,g,y)} ->
	a:Sig.alg -> sign:bytes -> pv:ProtocolVersion ->
	b:bytes{?p,g,y. dheb = DHEParamBytes(p,g,y) /\
		b = ServerKeyExchangeMsg_DHE(pv,p,g,y,a,sign)}
val parseServerKeyExchange_DHE: pv:ProtocolVersion -> cs:cipherSuite ->
	b:bytes ->
	((p:DHGroup.p * g:(;p)DHGroup.elt * y:(;p)DHGroup.elt * a:Sig.alg * sign:bytes){
	MessageBytes(HT_server_key_exchange,b) =
		ServerKeyExchangeMsg_DHE(pv,p,g,y,a,sign)
	}) Result

function val ServerKeyExchangeMsg_DH_anon: bytes * bytes * bytes -> bytes

val serverKeyExchangeBytes_DH_anon: bytes -> bytes -> bytes -> bytes
val parseServerKeyExchange_DH_anon: bytes -> (bytes * bytes * bytes) Result

//function val CertificateVerifyMsg: si:SessionInfo * (;si)PRF.masterSecret * a:Sig.alg * Cert.chain * (;a)Sig.pkey * log -> bytes
function val CertificateVerifyMsg: ProtocolVersion * Sig.alg * bytes -> bytes
private definition !pv,a,sign.
		 CertificateVerifyMsg(pv,a,sign) = MessageBytes(HT_certificate_verify,DigitallySignedBytes(a,sign,pv))

val makeCertificateVerifyBytes: si:SessionInfo -> (;si)PRF.masterSecret -> a:Sig.alg -> k:(;a)Sig.skey ->
  l:log{Sig.Msg(a,Sig.PK(k),l)} ->
	b:bytes * sign:bytes{
	  b = CertificateVerifyMsg(si.protocol_version,a,sign)
	}
val certificateVerifyCheck: si:SessionInfo -> (;si)PRF.masterSecret -> al:Sig.alg list -> l:log -> payload:bytes ->
	b:bool * sign:bytes{
	  b = true => (?a.
		   MessageBytes(HT_certificate_verify,payload) = CertificateVerifyMsg(si.protocol_version,a,sign)
		/\ ((si.protocol_version <> SSL_3p0 /\ Sig.Strong(a) /\ Sig.Honest(a,Cert.SigPKCert(si.clientID,a))) =>
                    Sig.Msg(a,Cert.SigPKCert(si.clientID,a),l)))}

//function val ServerFinishedMsg: si:SessionInfo * (;si)PRF.masterSecret * log -> bytes
function val ServerFinishedMsg: sVerifyData -> bytes

private definition !svd. ServerFinishedMsg(svd) = MessageBytes(HT_finished,svd)

//function val ClientFinishedMsg: si:SessionInfo * (;si)PRF.masterSecret * log -> bytes
function val ClientFinishedMsg: cVerifyData -> bytes

private definition !svd. ClientFinishedMsg(svd) = MessageBytes(HT_finished,svd)

predicate ServerLogBeforeClientCertificateRSA of SessionInfo * ProtocolVersion * log
predicate ServerLogBeforeClientCertificateRSA_Auth of SessionInfo * ProtocolVersion * log
predicate ServerLogBeforeClientCertificateRSA_NoAuth of SessionInfo * ProtocolVersion * log

private definition !si,pv,l.
  ServerLogBeforeClientCertificateRSA_Auth(si,pv,l) <=>
  ((si.client_auth = true /\  ServerLogBeforeClientCertificateRSA_Auth(si,pv,l)) \/
   (si.client_auth = false /\  ServerLogBeforeClientCertificateRSA_NoAuth(si,pv,l)))

private definition !si,pv,l.
  ServerLogBeforeClientCertificateRSA_Auth(si,pv,l) <=>
  (?crand,cpv,csl,cml,csess,ex1,ex2,ctl,sal,nl.
    l = (ClientHelloMsg(cpv,crand,csess,csl,cml,ex1)  @|
        (ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2) @|
         CertificateMsg(si.serverID) @|
         CertificateRequestMsg(si.protocol_version,ctl,sal,nl) @|
         ServerHelloDoneMsg([||]))))

private definition !si,pv,l.
  ServerLogBeforeClientCertificateRSA_NoAuth(si,pv,l) <=>
  (?cs,cm,sess,ex1,ex2.
     l = (ClientHelloMsg(pv,si.init_crand,sess,cs,cm,ex1) @|
          (ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2) @|
          CertificateMsg(si.serverID) @|
          ServerHelloDoneMsg([||]))))

predicate ServerLogBeforeClientCertificateDHE of SessionInfo * log
predicate ServerLogBeforeClientCertificateDHE_Auth of SessionInfo * log
predicate ServerLogBeforeClientCertificateDHE_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ServerLogBeforeClientCertificateDHE_Auth(si,l) <=>
  ((si.client_auth = true /\  ServerLogBeforeClientCertificateDHE_Auth(si,l)) \/
   (si.client_auth = false /\  ServerLogBeforeClientCertificateDHE_NoAuth(si,l)))

private definition !si,l.
  ServerLogBeforeClientCertificateDHE_Auth(si,l) <=>
  (?crand,cpv,csl,cml,csess,ex1,ex2,ctl,sal,nl,p,g,y,a,sign.
    l = (ClientHelloMsg(cpv,crand,csess,csl,cml,ex1)  @|
        (ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2) @|
         CertificateMsg(si.serverID) @|
         ServerKeyExchangeMsg_DHE(si.protocol_version,p,g,y,a,sign) @|
         CertificateRequestMsg(si.protocol_version,ctl,sal,nl) @|
         ServerHelloDoneMsg([||]))))

private definition !si,l.
  ServerLogBeforeClientCertificateDHE_NoAuth(si,l) <=>
  (?pv,cs,cm,sess,ex1,ex2,p,g,y,a,sign.
     l = (ClientHelloMsg(pv,si.init_crand,sess,cs,cm,ex1) @|
          (ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2) @|
           ServerKeyExchangeMsg_DHE(si.protocol_version,p,g,y,a,sign) @|
           CertificateMsg(si.serverID) @|
           ServerHelloDoneMsg([||]))))

predicate ServerLogBeforeClientKeyExchangeRSA of SessionInfo * ProtocolVersion * log
predicate ServerLogBeforeClientKeyExchangeRSA_Auth of SessionInfo * ProtocolVersion * log
predicate ServerLogBeforeClientKeyExchangeRSA_NoAuth of SessionInfo * ProtocolVersion * log

private definition !si,pv,l.
  ServerLogBeforeClientKeyExchangeRSA(si,pv,l) <=>
  ((si.client_auth = true /\  ServerLogBeforeClientKeyExchangeRSA_Auth(si,pv,l)) \/
   (si.client_auth = false /\  ServerLogBeforeClientKeyExchangeRSA_NoAuth(si,pv,l)))

private definition !si,pv,l.
  ServerLogBeforeClientKeyExchangeRSA_Auth(si,pv,l) <=>
  (?si',l'. ServerLogBeforeClientCertificateRSA_Auth(si',pv,l') /\
        SessionHelloParams(si,()) = SessionHelloParams(si',()) /\
        l = l' @| CertificateMsg(si.clientID))

private definition !si,pv,l.
  ServerLogBeforeClientKeyExchangeRSA_NoAuth(si,pv,l) <=>
  ServerLogBeforeClientCertificateRSA_NoAuth(si,pv,l)

predicate ServerLogBeforeClientKeyExchangeDHE of SessionInfo * log
predicate ServerLogBeforeClientKeyExchangeDHE_Auth of SessionInfo * log
predicate ServerLogBeforeClientKeyExchangeDHE_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ServerLogBeforeClientKeyExchangeDHE(si,l) <=>
  ((si.client_auth = true /\  ServerLogBeforeClientKeyExchangeDHE_Auth(si,l)) \/
   (si.client_auth = false /\  ServerLogBeforeClientKeyExchangeDHE_NoAuth(si,l)))

private definition !si,pv,l.
  ServerLogBeforeClientKeyExchangeDHE_Auth(si,l) <=>
  (?si',l'. ServerLogBeforeClientCertificateDHE_Auth(si',l') /\
        SessionHelloParams(si,()) = SessionHelloParams(si',()) /\
        l = l' @| CertificateMsg(si.clientID))

private definition !si,pv,l.
  ServerLogBeforeClientKeyExchangeDHE_NoAuth(si,l) <=>
  ServerLogBeforeClientCertificateDHE_NoAuth(si,l)

predicate ServerLogBeforeClientCertificateVerifyRSA of SessionInfo * log
predicate ServerLogBeforeClientCertificateVerifyRSA_Auth of SessionInfo * log
predicate ServerLogBeforeClientCertificateVerifyRSA_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ServerLogBeforeClientCertificateVerifyRSA(si,l) <=>
  (?si',pv,l',encpms,pk. ServerLogBeforeClientKeyExchangeRSA(si',pv,l') /\
      SessionHelloParams(si,()) = SessionHelloParams(si',()) /\
(*      si'.pmsData = RSAPMS(pk,pv,encpms) /\ *)
      l = l' @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))

predicate ServerLogBeforeClientCertificateVerifyDHE of SessionInfo * log
predicate ServerLogBeforeClientCertificateVerifyDHE_Auth of SessionInfo * log
predicate ServerLogBeforeClientCertificateVerifyDHE_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ServerLogBeforeClientCertificateVerifyDHE(si,l) <=>
  (?si',d,l'. ServerLogBeforeClientKeyExchangeDHE(si',l') /\
        SessionHelloParams(si,()) = SessionHelloParams(si',()) /\
(*      si'.pmsData = DHPMS(d) /\ *)
          l = l' @| ClientKeyExchangeMsg_DHE(d))

predicate ServerLogBeforeClientCertificateVerify of SessionInfo * log

private definition
 !si,l. ServerLogBeforeClientCertificateVerify(si,l) =>
  (ServerLogBeforeClientCertificateVerifyRSA(si,l) \/
   ServerLogBeforeClientCertificateVerifyDHE(si,l) \/
   (!a. si.cipher_suite <> CipherSuite(RSA,a) /\
        si.cipher_suite <> CipherSuite(DHE_RSA,a)))

private assume  !si,l.
    ServerLogBeforeClientCertificateVerifyRSA(si,l) =>
    ServerLogBeforeClientCertificateVerify(si,l)

private assume  !si,l.
    ServerLogBeforeClientCertificateVerifyDHE(si,l) =>
    ServerLogBeforeClientCertificateVerify(si,l)

predicate ServerLogBeforeClientFinishedRSA of SessionInfo * log
predicate ServerLogBeforeClientFinishedRSA_Auth of SessionInfo * log
predicate ServerLogBeforeClientFinishedRSA_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ServerLogBeforeClientFinishedRSA(si,l) <=>
  ((si.client_auth = true  /\ ServerLogBeforeClientFinishedRSA_Auth(si,l)) \/
  ((si.client_auth = false ) /\ ServerLogBeforeClientFinishedRSA_NoAuth(si,l)))

private definition !si,l.
  ServerLogBeforeClientFinishedRSA_Auth(si,l) <=>
  (?l',a,sign. ServerLogBeforeClientCertificateVerifyRSA(si,l') /\
   (l = l' @| CertificateVerifyMsg(si.protocol_version,a,sign)))

private definition !si,l.
  ServerLogBeforeClientFinishedRSA_NoAuth(si,l) <=>
  ServerLogBeforeClientCertificateVerifyRSA(si,l)

predicate ServerLogBeforeClientFinishedDHE of SessionInfo * log
predicate ServerLogBeforeClientFinishedDHE_Auth of SessionInfo * log
predicate ServerLogBeforeClientFinishedDHE_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ServerLogBeforeClientFinishedDHE(si,l) <=>
  ((si.client_auth = true  /\ ServerLogBeforeClientFinishedDHE_Auth(si,l)) \/
   ((si.client_auth = false ) /\ ServerLogBeforeClientFinishedDHE_NoAuth(si,l)))

private definition !si,l.
  ServerLogBeforeClientFinishedDHE_Auth(si,l) <=>
  (?l',a,sign. ServerLogBeforeClientCertificateVerifyDHE(si,l') /\
   (l = l' @| CertificateVerifyMsg(si.protocol_version,a,sign)))

private definition !si,l.
  ServerLogBeforeClientFinishedDHE_NoAuth(si,l) <=>
  ServerLogBeforeClientCertificateVerifyDHE(si,l)

predicate ServerLogBeforeClientFinished of SessionInfo * log
predicate ServerLogBeforeClientFinished_Auth of SessionInfo * log
predicate ServerLogBeforeClientFinished_NoAuth of SessionInfo * log
private definition
 !si,l. ServerLogBeforeClientFinished(si,l) <=>
  ((si.client_auth = true  /\ ServerLogBeforeClientFinished_Auth(si,l)) \/
  ((si.client_auth = false  ) /\ ServerLogBeforeClientFinished_NoAuth(si,l)))

private definition !si,l.
  ServerLogBeforeClientFinished_Auth(si,l) <=>
  (?l',a,sign. ServerLogBeforeClientCertificateVerify(si,l') /\
   (l = l' @| CertificateVerifyMsg(si.protocol_version,a,sign)))

private definition !si,l.
  ServerLogBeforeClientFinished_NoAuth(si,l) <=>
  ServerLogBeforeClientCertificateVerify(si,l)

predicate ServerLogBeforeServerFinishedRSA of SessionInfo * log
predicate ServerLogBeforeServerFinishedRSA_Auth of SessionInfo * log
predicate ServerLogBeforeServerFinishedRSA_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ServerLogBeforeServerFinishedRSA(si,l) <=>
  ((si.client_auth = true /\ ServerLogBeforeServerFinishedRSA_Auth(si,l)) \/
   (si.client_auth = false /\ ServerLogBeforeServerFinishedRSA_NoAuth(si,l)))

private definition !si,l.
  ServerLogBeforeServerFinishedRSA_Auth(si,l) <=>
  (?l',cvd. ServerLogBeforeClientFinishedRSA_Auth(si,l') /\
   (l' = l @| ClientFinishedMsg(cvd)))

private definition !si,l.
  ServerLogBeforeServerFinishedRSA_NoAuth(si,l) <=>
  (?l',cvd. ServerLogBeforeClientFinishedRSA_NoAuth(si,l') /\
   (l' = l @| ClientFinishedMsg(cvd)))

predicate ServerLogBeforeServerFinishedDHE of SessionInfo * log
predicate ServerLogBeforeServerFinishedDHE_Auth of SessionInfo * log
predicate ServerLogBeforeServerFinishedDHE_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ServerLogBeforeServerFinishedDHE(si,l) <=>
  ((si.client_auth = true /\ ServerLogBeforeServerFinishedDHE_Auth(si,l)) \/
   (si.client_auth = false /\ ServerLogBeforeServerFinishedDHE_NoAuth(si,l)))

private definition !si,l.
  ServerLogBeforeServerFinishedDHE_Auth(si,l) <=>
  (?l',cvd. ServerLogBeforeClientFinishedDHE_Auth(si,l') /\
   (l' = l @| ClientFinishedMsg(cvd)))

private definition !si,l.
  ServerLogBeforeServerFinishedDHE_NoAuth(si,l) <=>
  (?l',cvd. ServerLogBeforeClientFinishedDHE_NoAuth(si,l') /\
   (l' = l @| ClientFinishedMsg(cvd)))

predicate ServerLogBeforeServerFinished of SessionInfo * log
private definition
 !si,l. ServerLogBeforeServerFinished(si,l) <=>
  ((?a. si.cipher_suite = CipherSuite(RSA,a) /\ ServerLogBeforeServerFinishedRSA(si,l)) \/
   (?a. si.cipher_suite = CipherSuite(DHE_RSA,a) /\
       ServerLogBeforeServerFinishedDHE(si,l)) \/
   (!a. si.cipher_suite <> CipherSuite(RSA,a) /\
        si.cipher_suite <> CipherSuite(DHE_RSA,a)))

predicate ClientLogBeforeServerHello of random * log
predicate ClientLogBeforeServerCertificate of SessionInfo * log

private definition !cr,sid,l.
  ClientLogBeforeServerHello(cr,l) <=>
  (?pv,csid,cs,cm,ex1. l = ClientHelloMsg(pv,cr,sid,cs,cm,ex1))

ask !pv,cs,cm,ex1,cr,sid. ClientLogBeforeServerHello(cr,ClientHelloMsg(pv,cr,sid,cs,cm,ex1))

private definition !si,l.
  ClientLogBeforeServerCertificate(si,l) <=>
  (?l',cr,ex2.
     ClientLogBeforeServerHello(cr,l') /\
     l = l' @|
     ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2))

predicate ClientLogBeforeCertificateRequestRSA of SessionInfo * log
private definition !si,pv,l.
  ClientLogBeforeCertificateRequestRSA(si,l) <=>
  (?l'. ClientLogBeforeServerCertificate(si,l') /\
     l = l @| CertificateMsg(si.serverID))

predicate ClientLogBeforeServerKeyExchangeDHE of SessionInfo * log
private definition !si,pv,l.
  ClientLogBeforeServerKeyExchangeDHE(si,l) <=>
  (?l'. ClientLogBeforeServerCertificate(si,l') /\
     l = l @| CertificateMsg(si.serverID))

predicate ClientLogBeforeCertificateRequestDHE of SessionInfo * log
private definition !si,pv,l.
  ClientLogBeforeCertificateRequestDHE(si,l) <=>
  (?l',p,g,y,a,sign. ClientLogBeforeServerKeyExchangeDHE(si,l') /\
     l = l @| ServerKeyExchangeMsg_DHE(pv,p,g,y,a,sign))

predicate ClientLogBeforeServerHelloDoneRSA of SessionInfo * log
predicate ClientLogBeforeServerHelloDoneRSA_Auth of SessionInfo * log
predicate ClientLogBeforeServerHelloDoneRSA_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ClientLogBeforeServerHelloDoneRSA(si,l) <=>
  ((si.client_auth = true /\ ClientLogBeforeServerHelloDoneRSA_Auth(si,l)) \/
   (si.client_auth = false /\ ClientLogBeforeServerHelloDoneRSA_NoAuth(si,l)))

private definition !si,pv,l.
  ClientLogBeforeServerHelloDoneRSA_Auth(si,l) <=>
  (?l',ctl,sal,nl. ClientLogBeforeCertificateRequestRSA(si,l) /\
     l = CertificateRequestMsg(si.protocol_version,ctl,sal,nl))

private definition !si,pv,l.
  ClientLogBeforeServerHelloDoneRSA_NoAuth(si,l) <=>
  ClientLogBeforeCertificateRequestRSA(si,l)

predicate ClientLogBeforeServerHelloDoneDHE of SessionInfo * log
predicate ClientLogBeforeServerHelloDoneDHE_Auth of SessionInfo * log
predicate ClientLogBeforeServerHelloDoneDHE_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ClientLogBeforeServerHelloDoneDHE(si,l) <=>
  ((si.client_auth = true /\ ClientLogBeforeServerHelloDoneDHE_Auth(si,l)) \/
   (si.client_auth = false /\ ClientLogBeforeServerHelloDoneDHE_NoAuth(si,l)))

private definition !si,pv,l.
  ClientLogBeforeServerHelloDoneDHE_Auth(si,l) <=>
  (?l',ctl,sal,nl. ClientLogBeforeCertificateRequestDHE(si,l) /\
     l = CertificateRequestMsg(si.protocol_version,ctl,sal,nl))

private definition !si,pv,l.
  ClientLogBeforeServerHelloDoneDHE_NoAuth(si,l) <=>
  ClientLogBeforeCertificateRequestDHE(si,l)

predicate ClientLogBeforeCertificateVerifyRSA_Auth of SessionInfo * log

private definition !si,pv,l.
  ClientLogBeforeCertificateVerifyRSA_Auth(si,l) <=>
  (?l',encpms. ClientLogBeforeServerHelloDoneRSA_Auth(si,l') /\
     l = l' @| ServerHelloDoneMsg([||])
         @| CertificateMsg(si.clientID)
         @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))

predicate ClientLogBeforeCertificateVerifyDHE_Auth of SessionInfo * log

private definition !si,pv,l.
  ClientLogBeforeCertificateVerifyDHE_Auth(si,l) <=>
  (?l',b. ClientLogBeforeServerHelloDoneDHE_Auth(si,l') /\
     l = l' @| ServerHelloDoneMsg([||])
         @| CertificateMsg(si.clientID)
         @| ClientKeyExchangeMsg_DHE(b))

predicate ClientLogBeforeClientFinishedRSA of SessionInfo * log
predicate ClientLogBeforeClientFinishedRSA_Auth of SessionInfo * log
predicate ClientLogBeforeClientFinishedRSA_TryNoAuth of SessionInfo * log
predicate ClientLogBeforeClientFinishedRSA_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ClientLogBeforeClientFinishedRSA(si,l) <=>
  ((si.client_auth = true /\ si.clientID <> [] /\ ClientLogBeforeClientFinishedRSA_Auth(si,l)) \/
   (si.client_auth = true /\ si.clientID = [] /\ ClientLogBeforeClientFinishedRSA_TryNoAuth(si,l)) \/
   (si.client_auth = false /\ ClientLogBeforeClientFinishedRSA_NoAuth(si,l)))

private definition !si,pv,l.
  ClientLogBeforeClientFinishedRSA_Auth(si,l) <=>
  (?l',encpms,a,sign. ClientLogBeforeCertificateVerifyRSA_Auth(si,l') /\
     l = l'
         @| CertificateVerifyMsg(si.protocol_version,a,sign))

private definition !si,pv,l.
  ClientLogBeforeClientFinishedRSA_TryNoAuth(si,l) <=>
  (?l',l'',encpms. ClientLogBeforeServerHelloDoneRSA_Auth(si,l') /\
     l = l' @| ServerHelloDoneMsg([||])
         @| CertificateMsg(si.clientID)
         @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))

private definition !si,pv,l.
  ClientLogBeforeClientFinishedRSA_NoAuth(si,l) <=>
  (?l',encpms. ClientLogBeforeServerHelloDoneRSA_NoAuth(si,l') /\
     l = l' @| ServerHelloDoneMsg([||])
         @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))

predicate ClientLogBeforeClientFinishedDHE of SessionInfo * log
predicate ClientLogBeforeClientFinishedDHE_Auth of SessionInfo * log
predicate ClientLogBeforeClientFinishedDHE_TryNoAuth of SessionInfo * log
predicate ClientLogBeforeClientFinishedDHE_NoAuth of SessionInfo * log

private definition !si,pv,l.
  ClientLogBeforeClientFinishedDHE(si,l) <=>
  ((si.client_auth = true /\ si.clientID <> [] /\ ClientLogBeforeClientFinishedDHE_Auth(si,l)) \/
   (si.client_auth = true /\ si.clientID = [] /\ ClientLogBeforeClientFinishedDHE_TryNoAuth(si,l)) \/
   (si.client_auth = false /\ ClientLogBeforeClientFinishedDHE_NoAuth(si,l)))

private definition !si,pv,l.
  ClientLogBeforeClientFinishedDHE_Auth(si,l) <=>
  (?l',encpms,a,sign. ClientLogBeforeCertificateVerifyDHE_Auth(si,l') /\
     l = l'
         @| CertificateVerifyMsg(si.protocol_version,a,sign))

private definition !si,pv,l.
  ClientLogBeforeClientFinishedDHE_TryNoAuth(si,l) <=>
  (?l',l'',b. ClientLogBeforeServerHelloDoneDHE_Auth(si,l') /\
     l = l' @| ServerHelloDoneMsg([||])
         @| CertificateMsg(si.clientID)
         @| ClientKeyExchangeMsg_DHE(b))

private definition !si,pv,l.
  ClientLogBeforeClientFinishedDHE_NoAuth(si,l) <=>
  (?l',b. ClientLogBeforeServerHelloDoneDHE_NoAuth(si,l') /\
     l = l' @| ServerHelloDoneMsg([||])
         @| ClientKeyExchangeMsg_DHE(b))

predicate ClientLogBeforeClientFinished of SessionInfo * log
private definition
 !si,l. ClientLogBeforeClientFinished(si,l) <=>
  ((?a. si.cipher_suite = CipherSuite(RSA,a) /\ ClientLogBeforeClientFinishedRSA(si,l)) \/
   (?a. si.cipher_suite = CipherSuite(DHE_RSA,a) /\
   ClientLogBeforeClientFinishedDHE(si,l)) \/
   (!a. si.cipher_suite <> CipherSuite(RSA,a) /\
        si.cipher_suite <> CipherSuite(DHE_RSA,a)))

predicate ClientLogBeforeServerFinished of SessionInfo * log
private definition !si,l.
  ClientLogBeforeServerFinished(si,l) <=>
  (?l',cvd. ClientLogBeforeClientFinished(si,l') /\
     l = l' @| ClientFinishedMsg(cvd))

predicate ServerLogBeforeServerFinishedResume of SessionInfo * log
private definition !si,l.
  ServerLogBeforeServerFinishedResume(si,l) <=>
  (?crand,cpv,csl,cml,ex1,ex2,ctl,sal,nl.
    l = (ClientHelloMsg(cpv,crand,si.sessionID,csl,cml,ex1)  @|
        (ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2))))

predicate ServerLogBeforeClientFinishedResume of SessionInfo * log
private definition !si,l.
  ServerLogBeforeClientFinishedResume(si,l) <=>
  (?l',svd.   ServerLogBeforeServerFinishedResume(si,l') /\
    l = l' @| ServerFinishedMsg(svd))

predicate ClientLogBeforeServerFinishedResume of SessionInfo * log
private definition !si,l.
  ClientLogBeforeServerFinishedResume(si,l) <=>
  (?crand,cpv,csl,cml,ex1,ex2,ctl,sal,nl.
    l = (ClientHelloMsg(cpv,crand,si.sessionID,csl,cml,ex1)  @|
        (ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2))))

predicate ClientLogBeforeClientFinishedResume of SessionInfo * log
private definition !si,l.
  ClientLogBeforeClientFinishedResume(si,l) <=>
  (?l',svd.   ClientLogBeforeServerFinishedResume(si,l') /\
    l = l' @| ServerFinishedMsg(svd))

predicate Configure of Role * epoch * config
predicate Authorize of Role * SessionInfo
// If the user Authorize, we can put the session in the DB
private definition !r,si. Authorize(r,si) => SessionDB.Authorize(r,si)
// If we select a session from the DB, the user previously authorized it
private theorem !r,si. SessionDB.Authorize(r,si) => Authorize(r,si)

predicate SentCCS of Role * epoch (* CCS will be sent multiple times,
                                     one for each epoch *)
predicate EvSentFinishedFirst of ConnectionInfo * bool
predicate Negotiated of Role * SessionInfo * config * config
predicate CompleteEpoch of Role * epoch * config
predicate Complete of ConnectionInfo * config

val check_negotiation: r:Role -> si:SessionInfo -> cfg:config -> unit{?cfg'. Negotiated(r,si,cfg,cfg')}

(* Anonymous clients are authorized for client-unauthenticated sessions *)
private assume !si. (si.client_auth = false /\ si.clientID = []) => Authorize(Server,si)
private assume !r,si,si'. Authorize(Client,si) /\ SessionHelloParams(si,()) =
  SessionHelloParams(si',()) /\ si'.serverID = si.serverID => Authorize(Client,si')

private assume !r,si,si'. Authorize(Server,si) /\ SessionHelloParams(si,()) =
  SessionHelloParams(si',()) /\ si'.serverID = si.serverID /\ si'.clientID = si.clientID /\ si'.client_auth = si.client_auth => Authorize(Server,si')

private definition !a,k,t. Sig.Msg(a,k,t)
  <=> ((?si,pk,pv,e.
             ClientLogBeforeCertificateVerifyRSA_Auth(si,t) /\
             si.pmsData = RSAPMS(pk,pv,e) /\
             HonestRSAPMS(pk,pv,e) /\
             k = Cert.SigPKCert(si.clientID,a)) \/
        (?si,p,g,gx,gy.
           ClientLogBeforeCertificateVerifyDHE_Auth(si,t) /\
           si.pmsData = DHPMS(p,g,gx,gy) /\
           DH.HonestExponent(p,g,gy) => HonestDHPMS(p,g,gx,gy) /\
           k = Cert.SigPKCert(si.clientID,a)) \/
        (?si,p,g,gy. t = si.init_crand @| si.init_srand @|
           DHEParamBytes(p,g,gy) /\
           DH.HonestExponent(p,g,gy) /\
           k = Cert.SigPKCert(si.serverID,a)))

private definition !e,r,b. PRF.VerifyData(e,r,b)

  <=> ((r = Client /\
        Authorize(Client,EpochSI(e)) /\
        SentCCS(Client,e) /\
        ClientLogBeforeClientFinished(EpochSI(e),b)) \/
       (r = Server /\
        Authorize(Server,EpochSI(e)) /\
        SentCCS(Server,e) /\
        ServerLogBeforeServerFinished(EpochSI(e),b)) \/
       (r = Client /\
        Authorize(Client,EpochSI(e)) /\
        SentCCS(Client,e) /\
        ClientLogBeforeClientFinishedResume(EpochSI(e),b)) \/
       (r = Server /\
        Authorize(Server,EpochSI(e)) /\
        SentCCS(Server,e) /\
        ServerLogBeforeServerFinishedResume(EpochSI(e),b)))

private definition !role,e,cfg.
  CompleteEpoch(role,e,cfg)

  <=>
  ((StrongHS(EpochSI(e)) /\ HonestPMS(EpochSI(e).pmsData) =>
              (Authorize(Client,EpochSI(e)) /\
               Authorize(Server,EpochSI(e)) /\
               SentCCS(Client,e) /\
               SentCCS(Server,e) /\
               (?cfgPeer. Negotiated(role,EpochSI(e),cfg,cfgPeer))
              )) /\
   ((EpochSI(e).client_auth = true /\
     (?a. Sig.Honest(a,Cert.SigPKCert(EpochSI(e).clientID,a))) /\
     (?a. Sig.Honest(a,Cert.SigPKCert(EpochSI(e).serverID,a))) /\
     RSAKey.Honest(Cert.RSAPKCert(EpochSI(e).serverID)))
    => HonestPMS(EpochSI(e).pmsData)))

(* Negotiated remains to be defined but it can be a nice global spec of what HS is meant to achieve.
   Especially interesting would be proving that the result is the "best possible" *)

definition !ci,cfg. Complete(ci,cfg) <=>
        ( IsSuccEpoch(ci.id_in) /\ IsSuccEpoch(ci.id_out) /\
		  EpochSI(ci.id_in) = EpochSI(ci.id_out) /\
          CompleteEpoch(ci.role,ci.id_in,cfg))

type (;ci:ConnectionInfo) serverState =  (* note that the CertRequest bits are determined by the config *)
                    (* we may omit some ProtocolVersion, mostly a ghost variable *)
   | ClientHello                  of cVerifyData * sVerifyData

   | ClientCertificateRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKey.sk * l:log){ServerLogBeforeClientCertificateRSA(si,pv,l)}
   | ServerCheckingCertificateRSA of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKey.sk * l:log * certs:Cert.chain * b:bytes){ServerLogBeforeClientCertificateRSA(si,pv,l) /\ b = CertificateMsg(certs)}
   | ClientKeyExchangeRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKey.sk * l:log){ServerLogBeforeClientKeyExchangeRSA(si,pv,l) /\ Authorize(Server,si)}

   | ClientCertificateDH          of si:SessionInfo * l:log
   | ServerCheckingCertificateDH  of si:SessionInfo * l:log * b:bytes
   | ClientKeyExchangeDH          of si:SessionInfo * l:log

   | ClientCertificateDHE         of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * l:log{
       ServerLogBeforeClientCertificateDHE(si,l)}

   | ServerCheckingCertificateDHE of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * l:log * c:Cert.chain * b:bytes{
       ServerLogBeforeClientCertificateDHE(si,l) /\
       b = CertificateMsg(c)}

   | ClientKeyExchangeDHE         of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * l:log{
       ServerLogBeforeClientKeyExchangeDHE(si,l) /\ Authorize(Server,si)}

   | ClientKeyExchangeDH_anon     of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log

   | CertificateVerify            of (si:SessionInfo * (;si)PRF.masterSecret * l:log){si.client_auth = true /\ ServerLogBeforeClientCertificateVerify(si,l) /\ Authorize(Server,si)}
   | ClientCCS                    of (si:SessionInfo * (;si)PRF.masterSecret * l:log){ServerLogBeforeClientFinished(si,l) /\ Authorize(Server,si)}
   | ClientFinished               of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;e)StatefulLHAE.writer * l:log){
       IsSuccEpoch(ci.id_in) /\ EpochSI(e)=si /\ ServerLogBeforeClientFinished(si,l) /\ Authorize(Server,si)}
   (* by convention, the parameters are named si, cv, cr', sr', ms, log *)
   | ServerWritingCCS             of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;e)StatefulLHAE.writer * cv:cVerifyData * l:log){
                                       EpochSI(e)=si /\ ServerLogBeforeServerFinished(si,l) /\
         (* PRF.VerifyData(e,Client,cv) /\ *)
         Authorize(Server,si)}
   | ServerWritingFinished        of si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * cv:cVerifyData * sv:sVerifyData{
       EpochSI(e)=si /\
         (* PRF.VerifyData(e,Client,cv) /\ PRF.VerifyData(e,Server,sv) /\ *)
         Authorize(Server,si)}

   | ServerWritingCCSResume       of (ew:succEpoch * (;ew)StatefulLHAE.writer * er:succEpoch * (;er)StatefulLHAE.reader * (;epochSI(ew))PRF.masterSecret * l:log){EpochSI(ew)=EpochSI(er) /\ ServerLogBeforeServerFinishedResume(EpochSI(ew),l) /\ Authorize(Server,EpochSI(ew))}
   | ClientCCSResume              of e:succEpoch * (;e)StatefulLHAE.reader * sVerifyData * (;EpochSI(e))PRF.masterSecret * l:log{ServerLogBeforeClientFinishedResume(EpochSI(e),l) /\ ci.id_in = Pred(e) /\ Authorize(Server,EpochSI(e))}
   | ClientFinishedResume         of si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * sv:sVerifyData * log{
       EpochSI(e)=si /\
(* PRF.VerifyData(e,Server,sv) /\ *)
         Authorize(Server,EpochSI(e))}

   | ServerIdle                   of cVerifyData * sVerifyData
   (* the ProtocolVersion is the highest TLS version proposed by the client *)

type (;ci:ConnectionInfo) clientState =
   | ServerHello                  of cr:crand * sid:sessionID (* * bytes for extensions? *) * cvd:cVerifyData * svd:sVerifyData * l:log{ClientLogBeforeServerHello(cr,l)}

   | ServerCertificateRSA         of si:SessionInfo * l:log{ClientLogBeforeServerCertificate(si,l)}
   | ClientCheckingCertificateRSA of si:SessionInfo * l:log * ser:Cert.cert list * pv:ProtocolVersion option * b:bytes{ClientLogBeforeServerCertificate(si,l) /\ b = CertificateMsg(ser)}
   | CertificateRequestRSA        of si:SessionInfo * l:log{ClientLogBeforeCertificateRequestRSA(si,l) /\ Authorize(Client,si)} (* both certificate request and hellodone will be accepted *)
   | ServerHelloDoneRSA           of si:SessionInfo * c:Cert.sign_cert * l:log{ClientLogBeforeServerHelloDoneRSA(si,l) /\ Authorize(Client,si)}

   | ServerCertificateDH          of SessionInfo * log
   | ClientCheckingCertificateDH  of SessionInfo * log * ProtocolVersion option * bytes
   | CertificateRequestDH         of SessionInfo * log (* We pick our cert and store it in sessionInfo as soon as the server requests it.
                                                         We put None if we don't have such a certificate, and we know whether to send
                                                         the Certificate message or not based on the state when we receive the Finished message *)
   | ServerHelloDoneDH            of SessionInfo * log

   | ServerCertificateDHE         of si:SessionInfo * l:log{ClientLogBeforeServerCertificate(si,l)}
   | ClientCheckingCertificateDHE of si:SessionInfo * l:log * ProtocolVersion option * b:bytes{ClientLogBeforeServerCertificate(si,l) (* /\ b = CertificateMsg(ser) *) }
   | ServerKeyExchangeDHE         of si:SessionInfo * l:log{ClientLogBeforeServerKeyExchangeDHE(si,l) /\ Authorize(Client,si)}
   | CertificateRequestDHE        of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * l:log{ClientLogBeforeCertificateRequestDHE(si,l) /\ Authorize(Client,si)}
   | ServerHelloDoneDHE           of si:SessionInfo * Cert.sign_cert * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * l:log{ClientLogBeforeServerHelloDoneDHE(si,l) /\ Authorize(Client,si)}

   | ServerKeyExchangeDH_anon of SessionInfo * log (* Not supported yet *)
   | ServerHelloDoneDH_anon of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * log

   | ClientWritingCCS       of si:SessionInfo * (;si)PRF.masterSecret * l:log{ClientLogBeforeClientFinished(si,l) /\ Authorize(Client,si)}
   | ServerCCS              of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;e)StatefulLHAE.reader * cv:cVerifyData * l:log){ EpochSI(e)=si  /\ ClientLogBeforeServerFinished(si,l) /\
         ci.id_in = Pred(e) /\
         (* PRF.VerifyData(e,Client,cv) /\ *)
         Authorize(Client,si)}
   | ServerFinished         of si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * cv:cVerifyData * l:log{ClientLogBeforeServerFinished(si,l) /\
                                                                                                               EpochSI(e)=si  /\
         (* ci.id_in = Pred(e) /\ *)
         (* PRF.VerifyData(e,Client,cv) /\ *)
         Authorize(Client,si)}

   | ServerCCSResume        of (ew:succEpoch * (;ew)StatefulLHAE.writer * er:succEpoch * (;er)StatefulLHAE.reader * (;EpochSI(ew))PRF.masterSecret * l:log){EpochSI(ew)=EpochSI(er) /\ ci.id_in = Pred(er) /\ ClientLogBeforeServerFinishedResume(EpochSI(ew),l) /\ Authorize(Client,EpochSI(ew))}
   | ServerFinishedResume   of e:succEpoch * (;e)StatefulLHAE.writer * (;EpochSI(e))PRF.masterSecret * l:log{ClientLogBeforeServerFinishedResume(EpochSI(e),l) /\ Authorize(Client,EpochSI(e))}
   | ClientWritingCCSResume of e:succEpoch * w:(;e)StatefulLHAE.writer * (;EpochSI(e))PRF.masterSecret * sv:sVerifyData * l:log{ClientLogBeforeClientFinishedResume(EpochSI(e),l) /\ (* PRF.VerifyData(e,Server,sv) /\ *)
Authorize(Client,EpochSI(e)) /\
ci.id_out = Pred(e) /\
         StatefulLHAE.History(e,StatefulLHAE.WriterState,w) =
         StatefulPlain.EmptyHistory(e) }
   | ClientWritingFinishedResume of cVerifyData * sVerifyData

   | ClientIdle             of cVerifyData * sVerifyData

type (;ci:ConnectionInfo) protoState = // Cannot use Client and Server, otherwise clashes with Role
  | PSClient of (;ci) clientState
  | PSServer of (;ci) serverState

val clientState: ci:ConnectionInfo -> c:(;ci) clientState -> p:(;ci) protoState{p = PSClient(c)}
val serverState: ci:ConnectionInfo -> c:(;ci) serverState -> p:(;ci) protoState{p = PSServer(c)}

private type (;ci:ConnectionInfo) hs_state = {
  (* I/O buffers *)
  hs_outgoing    : bytes;                  (* outgoing data *)
  hs_incoming    : bytes;                  (* partial incoming HS message *)
  (* local configuration *)
  poptions: config;
  sDB: SessionDB.SessionDB;
  (* current handshake & session we are establishing *)
  pstate: (;ci) protoState;
}

(*--- controlinterface *)
(* Control Interface *)

function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
private definition !ci,s. Config(ci,s) = s.poptions

type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

val init:  rl:Role  -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){Config(ci,s) = c /\
                ci.role = rl /\
		IsInitEpoch(ci.id_in) /\
		IsInitEpoch(ci.id_out)}

val resume: nextSID:sessionID -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\
                ci.role = Client /\
		IsInitEpoch(ci.id_in) /\
		IsInitEpoch(ci.id_out)}

val rehandshake: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/
                 (b = false /\ Config(ci,s') = Config(ci,s)))}

val rekey: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	   b:bool * s':(;ci)hs_state{((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s)))}

val request:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
                 b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s)))}

val getPrincipal:  ci:ConnectionInfo -> s:(;ci)hs_state -> string
val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> s':(;ci,Config(ci,s))nextState
(*{SameStreams(ci,s,s')} *)

val getNextEpochs: ci:ConnectionInfo -> si:SessionInfo -> crand -> srand -> ci':ConnectionInfo{
    IsSuccEpoch(ci'.id_in) /\
    IsSuccEpoch(ci'.id_out) /\
    EpochSI(ci'.id_in) = si /\
    EpochSI(ci'.id_out) = si /\
    ci.id_out = Pred(ci'.id_out) /\
    ci.id_in = Pred(ci'.id_in) /\
    ci.role = ci'.role
}

(*--- networkinterface *)
(* Network Interface*)

type (;ci:ConnectionInfo, hs:(;ci) hs_state) outgoing =
  | OutIdle of s':(;ci,Config(ci,hs))nextState
  | OutSome of (rg:range * f:(;ci.id_out,HSFragment.EmptyStream(ci.id_out),rg)HSFragment.plain * s':(;ci,Config(ci,hs))nextState)
  | OutCCS of  (rg:range * f:(;ci.id_out,HSFragment.EmptyStream(ci.id_out),rg)HSFragment.plain *
               ci':ConnectionInfo * cs:(;ci'.id_out,StatefulLHAE.WriterState)StatefulLHAE.state * s':(;ci',Config(ci,hs))nextState)
               { StatefulLHAE.History(ci'.id_out,StatefulLHAE.WriterState,cs) = StatefulPlain.EmptyHistory(ci'.id_out) /\
                 ci.id_out = Pred(ci'.id_out) /\ IsSuccEpoch(ci'.id_out) /\
                 ci.id_in = ci'.id_in /\
                 ci.role = ci'.role /\
				 ci.id_rand = ci'.id_rand}
  | OutFinished of (rg:range * f:(;ci.id_out,HSFragment.EmptyStream(ci.id_out),rg)HSFragment.plain * s':(;ci,Config(ci,hs))nextState){
				EvSentFinishedFirst(ci,true)}
  | OutComplete of (rg:range * f:(;ci.id_out,HSFragment.EmptyStream(ci.id_out),rg)HSFragment.plain * s':(;ci,Config(ci,hs))nextState)
                   {Complete(ci,Config(ci,hs))}
val next_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> (;ci,s)outgoing

type (;ci:ConnectionInfo,c:config)incoming =
  | InAck of (;ci,c)nextState
  | InVersionAgreed  of (;ci,c)nextState * ProtocolVersion
  | InQuery of Cert.chain * advice:bool * (;ci,c)nextState
  | InFinished of (;ci,c)nextState {EvSentFinishedFirst(ci,false)}
  | InComplete of (;ci,c)nextState {Complete(ci,c)}
  | InError of alertDescription * string * (;ci,c)nextState
val recv_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)HSFragment.fragment ->
                   (;ci,Config(ci,s))incoming
val authorize:     ci:ConnectionInfo -> s:(;ci)hs_state ->
                   c:Cert.chain -> (;ci,Config(ci,s))incoming

type (;ci:ConnectionInfo,c:config)incomingCCS =
  | InCCSAck of ci':ConnectionInfo * (;ci'.id_in,StatefulLHAE.ReaderState)StatefulLHAE.state * (;ci',c)nextState
				{ci.id_out = ci'.id_out /\ ci.id_in = Pred(ci'.id_in)}
  | InCCSError of alertDescription * string * (;ci,c)nextState
val recv_ccs     : ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)HSFragment.fragment ->
                   (;ci,Config(ci,s))incomingCCS

function val GetMinVersion: ci:ConnectionInfo * (;ci)hs_state -> ProtocolVersion
private definition !ci,s. GetMinVersion(ci,s) = s.poptions.minVer
val getMinVersion: ci:ConnectionInfo -> s:(;ci)hs_state ->
	pv:ProtocolVersion{pv = GetMinVersion(ci,s)}

(*--- end *)

(* INTERNAL HS VERIFICATION (ALL THESE DEFS ARE PRIVATE) *)

val find_client_cert_sign: certType list -> Sig.alg list -> string list ->
	ProtocolVersion -> Cert.hint -> Cert.sign_cert
val getCertificateBytes: si:SessionInfo ->
  cert_req:(Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
  (b:bytes * cl:Cert.chain){
    (si.client_auth = true /\  b = CertificateMsg(cl)) \/
    (si.client_auth = false /\ b = [||])}

val getCertificateVerifyBytes: si:SessionInfo -> (;si) PRF.masterSecret ->
  cert_req:(Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
  l:log{!cl,a,k. cert_req = Some((cl,a,k)) => Sig.Msg(a,Sig.PK(k),l)} ->
  b:bytes{(!cl,a,k. (cert_req = Some((cl,a,k)) /\ si.client_auth = true) =>
                    (?sign. b = CertificateVerifyMsg(si.protocol_version,a,sign))) /\
          ((cert_req = None \/ si.client_auth = false) => b = [||])}

val prepare_client_output_full_RSA: ci:ConnectionInfo -> (;ci)hs_state ->
	si:SessionInfo -> (Cert.chain * a:Sig.alg * (;a)Sig.skey) option -> l:log ->
	((;ci)hs_state * si':SessionInfo * (;si)PRF.masterSecret * log) Result
val prepare_client_output_full_DHE: ci:ConnectionInfo -> (;ci)hs_state ->
	si:SessionInfo -> (Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
	p:DHGroup.p -> (;p)DHGroup.g -> (;p)DHGroup.elt -> log ->
	((;ci)hs_state * si':SessionInfo * (;si)PRF.masterSecret * log) Result
val on_serverHello_full: ci:ConnectionInfo -> cr:crand -> l:log -> to_log:bytes ->
         (pv:ProtocolVersion * sr:random * sid:sessionID * cs:cipherSuite * cm:Compression * ext:bytes){
         ClientLogBeforeServerHello(cr,l) /\
         to_log = ServerHelloMsg(pv,sr,sid,cs,cm,ext)} ->
 	 (;ci) protoState
val parseMessageState: ci:ConnectionInfo -> hs:(;ci)hs_state ->
	(hs':(;ci)hs_state * ht:HandshakeType * pl:bytes * to_log:bytes{Config(ci,hs) = Config(ci,hs') /\
                                                                     to_log = MessageBytes(ht,pl)}) option Result
val recv_fragment_client: ci:ConnectionInfo -> s:(;ci)hs_state -> ProtocolVersion option ->
	(;ci,Config(ci,s))incoming

val prepare_server_output_full_RSA: ci:ConnectionInfo -> s:(;ci)hs_state -> si:SessionInfo ->
	pv:ProtocolVersion -> Sig.alg list -> cVerifyData -> sVerifyData -> l:log{
          ?csid,cs,cm,ex. l = ClientHelloMsg(pv,si.init_crand,csid,cs,cm,ex)
        }->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val prepare_server_output_full_DH: 'a -> 'b -> 'c -> 'd -> res:('e Result){?x,y. res = Error(x,y)}
val prepare_server_output_full_DHE: ci:ConnectionInfo -> s:(;ci)hs_state -> SessionInfo ->
	Sig.alg list -> cVerifyData -> sVerifyData -> log ->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val prepare_server_output_full_DH_anon: ci:ConnectionInfo -> s:(;ci)hs_state -> SessionInfo ->
	cVerifyData -> sVerifyData -> log ->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val prepare_server_output_full: ci:ConnectionInfo -> s:(;ci)hs_state -> si:SessionInfo ->
	pv:ProtocolVersion -> cVerifyData -> sVerifyData -> l:log{
          ?csid,cs,cm,ex. l = ClientHelloMsg(pv,si.init_crand,csid,cs,cm,ex)
        } ->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val negotiate: 'a list -> 'a list -> 'a option
val prepare_server_output_resumption: ci:ConnectionInfo -> s:(;ci)hs_state -> crand ->
	si:SessionInfo -> (;si)PRF.masterSecret -> cVerifyData -> sVerifyData -> log ->
	s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}
val startServerFull: ci:ConnectionInfo -> s:(;ci)hs_state ->
  ch:(ProtocolVersion * crand * sessionID * cipherSuites * Compression list * bytes) ->// CHello
  cVerifyData -> sVerifyData ->
  l:log{!pv,cr,sid,cs,cms,ex. ch = (pv,cr,sid,cs,cms,ex) =>
         l = ClientHelloMsg(pv,cr,sid,cs,cms,ex)} ->
  ((s':(;ci)hs_state{Config(ci,s') = Config(ci,s)}) * ProtocolVersion) Result
val recv_fragment_server: ci:ConnectionInfo -> s:(;ci)hs_state -> pv:ProtocolVersion option ->
	(;ci,Config(ci,s))incoming
val enqueue_fragment: ci:ConnectionInfo -> s1:(;ci)hs_state -> bytes -> s2:(;ci)hs_state{Config(ci,s1) = Config(ci,s2)}

val sessionInfoCertBytesAuth: (si:SessionInfo) ->
  (clo: (Cert.chain * a:Sig.alg * (;a)Sig.skey) option) ->
  (si':SessionInfo * b:bytes){
    (si.client_auth = false /\ si' = si /\ b = [||]) \/
    (si.client_auth = true /\ clo = None /\ b = CertificateMsg([]) /\ si = si') \/
    (si.client_auth = true /\  (?cl,a',b'. clo = Some((cl,a',b')) /\ b = CertificateMsg(cl) /\ si'.clientID = cl))}

val certificateVerifyBytesAuth: si:SessionInfo ->
  (;si) PRF.masterSecret ->
  cert_req: (Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
  log:bytes{!cl,a,sk. cert_req = Some((cl,a,sk)) => Sig.Msg(a,Sig.PK(sk),log)} ->
  b:bytes{
    ((si.client_auth = false \/ cert_req = None) /\ b = [||]) \/
     (si.client_auth = true /\
         (?cl,a,sk,sign.
            cert_req = Some((cl,a,sk)) /\
            b = CertificateVerifyMsg(si.protocol_version,a,sign)))}
