(*
 * Copyright (c) 2012--2013 MSR-INRIA Joint Center. All rights reserved.
 * 
 * This code is distributed under the terms for the CeCILL-B (version 1)
 * license.
 * 
 * You should have received a copy of the CeCILL-B (version 1) license
 * along with this program.  If not, see:
 * 
 *   http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 *)

module Handshake

open Bytes
open Error
open TLSError
open TLSInfo
open Range
open StatefulLHAE
open TLSConstants
open TLSExtensions
open HandshakeMessages

predicate Configure of Role * epoch * config
predicate Authorize of Role * SessionInfo
// If the user Authorize, we can put the session in the DB
private definition !r,si. Authorize(r,si) => SessionDB.Authorize(r,si)
// If we select a session from the DB, the user previously authorized it
private theorem !r,si. SessionDB.Authorize(r,si) => Authorize(r,si)

predicate SentCCS of Role * epoch (* CCS will be sent multiple times,
                                     one for each epoch *)
predicate EvSentFinishedFirst of ConnectionInfo * bool
predicate Negotiated of Role * SessionInfo * config * config
predicate CompleteEpoch of Role * epoch * config
predicate Complete of ConnectionInfo * config

val check_negotiation: r:Role -> si:SessionInfo -> cfg:config -> unit{?cfg'. Negotiated(r,si,cfg,cfg')}

(* Anonymous clients are authorized for client-unauthenticated sessions *)
private assume !si. (si.client_auth = false /\ si.clientID = []) => Authorize(Server,si)
private assume !r,si,si'. Authorize(Client,si) /\ SessionHelloParams(si,()) =
  SessionHelloParams(si',()) /\ si'.serverID = si.serverID => Authorize(Client,si')

private assume !r,si,si'. Authorize(Server,si) /\ SessionHelloParams(si,()) =
  SessionHelloParams(si',()) /\ si'.serverID = si.serverID /\ si'.clientID = si.clientID /\ si'.client_auth = si.client_auth => Authorize(Server,si')

private definition !a,k,t. Sig.Msg(a,k,t)
  <=> ((?si,pk,pv,e.
             ClientLogBeforeCertificateVerifyRSA_Auth(si,t) /\
             si.pmsData = RSAPMS(pk,pv,e) /\
             HonestRSAPMSData(pk,pv,e) /\
             k = Cert.SigPKCert(si.clientID,a)) \/
        (?si,p,g,gx,gy.
           ClientLogBeforeCertificateVerifyDHE_Auth(si,t) /\
           si.pmsData = DHPMS(p,g,gx,gy) /\ (* PP should also be included in the following as a precondition *)
           DH.HonestExponent(p,g,gy) => HonestDHPMSData(p,g,gx,gy) /\
           k = Cert.SigPKCert(si.clientID,a)) \/
        (?si,p,g,gy. B(t) = B(si.init_crand) @| B(si.init_srand) @|
           DHEParamBytes(p,g,gy) /\
           DH.HonestExponent(p,g,gy) /\ (* PP should also be included? *)
           k = Cert.SigPKCert(si.serverID,a)))

private definition !msi,r,b. PRF.VerifyData(msi,r,b)

  <=> ((?e. msi = MsI(EpochSI(e)) /\
        r = Client /\
        Authorize(Client,EpochSI(e)) /\
        SentCCS(Client,e) /\
        ClientLogBeforeClientFinished(EpochSI(e),b)) \/
       (?e. msi = MsI(EpochSI(e)) /\
        r = Server /\
        Authorize(Server,EpochSI(e)) /\
        SentCCS(Server,e) /\
        ServerLogBeforeServerFinished(EpochSI(e),b)) \/
       (?e. msi = MsI(EpochSI(e)) /\
        r = Client /\
        Authorize(Client,EpochSI(e)) /\
        SentCCS(Client,e) /\
        ClientLogBeforeClientFinishedResume(EpochSI(e),b)) \/
       (?e. msi = MsI(EpochSI(e)) /\
        r = Server /\
        Authorize(Server,EpochSI(e)) /\
        SentCCS(Server,e) /\
        ServerLogBeforeServerFinishedResume(EpochSI(e),b)))

(*
predicate CompleteEpoch' of Role * epoch * config
private definition !role, e. CompleteEpoch'(role,e)
  <=> SentCCS(role,e) /\
      ( SafeVD(Id(e)) => SentCCS(DualRole(role),e) )
*)

private definition !role,e,cfg.
  CompleteEpoch(role,e,cfg)

  <=>
  ((AuthId(Id(e)) =>
              (Authorize(Client,EpochSI(e)) /\ //gives us Match
               Authorize(Server,EpochSI(e)) /\
               Open(e))) /\
   ((EpochSI(e).client_auth = true /\
     (?a. Sig.Honest(a,Cert.SigPKCert(EpochSI(e).clientID,a))) /\
     (?a. Sig.Honest(a,Cert.SigPKCert(EpochSI(e).serverID,a))) /\
     RSAKey.Honest(Cert.RSAPKCert(EpochSI(e).serverID)))
    => HonestPMSData(EpochSI(e).pmsData)))

(* Negotiated remains to be defined but it can be a nice global spec of what HS is meant to achieve.
   Especially interesting would be proving that the result is the "best possible" *)

definition !ci,cfg. Complete(ci,cfg) <=>
        ( IsSuccEpoch(ci.id_in)  /\ IsValidEpoch(ci.id_in)  /\ IsValidEpoch(Pred(ci.id_in))  /\
		  IsSuccEpoch(ci.id_out) /\ IsValidEpoch(ci.id_out) /\ IsValidEpoch(Pred(ci.id_out)) /\
		  EpochSI(ci.id_in) = EpochSI(ci.id_out) /\
          CompleteEpoch(ci.role,ci.id_in,cfg) /\
		  CompleteEpoch(ci.role,ci.id_out,cfg))

ask !ci,cfg. Complete(ci,cfg) =>
	(
		( AuthId(Id(ci.id_in))  => Open(ci.id_in ) ) /\
		( AuthId(Id(ci.id_out)) => Open(ci.id_out) )
	)

type (;ci:ConnectionInfo) serverState =  (* note that the CertRequest bits are determined by the config *)
                    (* we may omit some ProtocolVersion, mostly a ghost variable *)
   | ClientHello                  of cVerifyData * sVerifyData

   | ClientCertificateRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKey.sk * l:log){ServerLogBeforeClientCertificateRSA(si,pv,l)}
   | ServerCheckingCertificateRSA of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKey.sk * l:log * certs:Cert.chain * b:bytes){ServerLogBeforeClientCertificateRSA(si,pv,l) /\ B(b) = CertificateMsg(certs)}
   | ClientKeyExchangeRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKey.sk * l:log){ServerLogBeforeClientKeyExchangeRSA(si,pv,l) /\ Authorize(Server,si)}

   | ClientCertificateDH          of si:SessionInfo * l:log
   | ServerCheckingCertificateDH  of si:SessionInfo * l:log * b:bytes
   | ClientKeyExchangeDH          of si:SessionInfo * l:log

   | ClientCertificateDHE         of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * l:log{
       ServerLogBeforeClientCertificateDHE(si,l)}

   | ServerCheckingCertificateDHE of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * l:log * c:Cert.chain * b:bytes{
       ServerLogBeforeClientCertificateDHE(si,l) /\
       B(b) = CertificateMsg(c)}

   | ClientKeyExchangeDHE         of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * l:log{
       ServerLogBeforeClientKeyExchangeDHE(si,l) /\ Authorize(Server,si)}

   | ClientKeyExchangeDH_anon     of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log

   | CertificateVerify            of (si:SessionInfo * (;si)PRF.masterSecret * l:log){si.client_auth = true /\ ServerLogBeforeClientCertificateVerify(si,l) /\ Authorize(Server,si)}
   | ClientCCS                    of (si:SessionInfo * (;si)PRF.masterSecret * l:log){ServerLogBeforeClientFinished(si,l) /\ Authorize(Server,si)}
   | ClientFinished               of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;Id(e))StatefulLHAE.writer * l:log){
       IsSuccEpoch(ci.id_in) /\ EpochSI(e)=si /\ ServerLogBeforeClientFinished(si,l) /\ Authorize(Server,si)}
   (* by convention, the parameters are named si, cv, cr', sr', ms, log *)
   | ServerWritingCCS             of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;Id(e))StatefulLHAE.writer * cv:cVerifyData * l:log){
                                       EpochSI(e)=si /\ ServerLogBeforeServerFinished(si,l) /\
         (* PRF.VerifyData(e,Client,cv) /\ *)
         Authorize(Server,si)}
   | ServerWritingFinished        of si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * cv:cVerifyData * sv:sVerifyData{
       EpochSI(e)=si /\
         (* PRF.VerifyData(e,Client,cv) /\ PRF.VerifyData(e,Server,sv) /\ *)
         Authorize(Server,si)}

   | ServerWritingCCSResume       of (ew:succEpoch * (;Id(ew))StatefulLHAE.writer * er:succEpoch * (;Id(er))StatefulLHAE.reader * (;EpochSI(ew))PRF.masterSecret * l:log){EpochSI(ew)=EpochSI(er) /\ ServerLogBeforeServerFinishedResume(EpochSI(ew),l) /\ Authorize(Server,EpochSI(ew))}
   | ClientCCSResume              of e:succEpoch * (;Id(e))StatefulLHAE.reader * sVerifyData * (;EpochSI(e))PRF.masterSecret * l:log{ServerLogBeforeClientFinishedResume(EpochSI(e),l) /\ ci.id_in = Pred(e) /\ Authorize(Server,EpochSI(e))}
   | ClientFinishedResume         of si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * sv:sVerifyData * log{
       EpochSI(e)=si /\
(* PRF.VerifyData(e,Server,sv) /\ *)
         Authorize(Server,EpochSI(e))}

   | ServerIdle                   of cVerifyData * sVerifyData
   (* the ProtocolVersion is the highest TLS version proposed by the client *)

type (;ci:ConnectionInfo) clientState =
   | ServerHello                  of cr:crand * sid:sessionID (* * bytes for extensions? *) * cvd:cVerifyData * svd:sVerifyData * l:log{ClientLogBeforeServerHello(cr,l)}

   | ServerCertificateRSA         of si:SessionInfo * l:log{ClientLogBeforeServerCertificate(si,l)}
   | ClientCheckingCertificateRSA of si:SessionInfo * l:log * ser:Cert.cert list * pv:ProtocolVersion option * b:bytes{ClientLogBeforeServerCertificate(si,l) /\ b = CertificateMsg(ser)}
   | CertificateRequestRSA        of si:SessionInfo * l:log{ClientLogBeforeCertificateRequestRSA(si,l) /\ Authorize(Client,si)} (* both certificate request and hellodone will be accepted *)
   | ServerHelloDoneRSA           of si:SessionInfo * c:Cert.sign_cert * l:log{ClientLogBeforeServerHelloDoneRSA(si,l) /\ Authorize(Client,si)}

   | ServerCertificateDH          of SessionInfo * log
   | ClientCheckingCertificateDH  of SessionInfo * log * ProtocolVersion option * bytes
   | CertificateRequestDH         of SessionInfo * log (* We pick our cert and store it in sessionInfo as soon as the server requests it.
                                                         We put None if we don't have such a certificate, and we know whether to send
                                                         the Certificate message or not based on the state when we receive the Finished message *)
   | ServerHelloDoneDH            of SessionInfo * log

   | ServerCertificateDHE         of si:SessionInfo * l:log{ClientLogBeforeServerCertificate(si,l)}
   | ClientCheckingCertificateDHE of si:SessionInfo * l:log * ProtocolVersion option * b:bytes{ClientLogBeforeServerCertificate(si,l) (* /\ b = CertificateMsg(ser) *) }
   | ServerKeyExchangeDHE         of si:SessionInfo * l:log{ClientLogBeforeServerKeyExchangeDHE(si,l) /\ Authorize(Client,si)}
   | CertificateRequestDHE        of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * l:log{ClientLogBeforeCertificateRequestDHE(si,l) /\ Authorize(Client,si)}
   | ServerHelloDoneDHE           of si:SessionInfo * Cert.sign_cert * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * l:log{ClientLogBeforeServerHelloDoneDHE(si,l) /\ Authorize(Client,si)}

   | ServerKeyExchangeDH_anon of SessionInfo * log (* Not supported yet *)
   | ServerHelloDoneDH_anon of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * log

   | ClientWritingCCS       of si:SessionInfo * (;si)PRF.masterSecret * l:log{ClientLogBeforeClientFinished(si,l) /\ Authorize(Client,si)}
   | ServerCCS              of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;Id(e))StatefulLHAE.reader * cv:cVerifyData * l:log){ EpochSI(e)=si  /\ ClientLogBeforeServerFinished(si,l) /\
         ci.id_in = Pred(e) /\
         (* PRF.VerifyData(e,Client,cv) /\ *)
         Authorize(Client,si)}
   | ServerFinished         of si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * cv:cVerifyData * l:log{ClientLogBeforeServerFinished(si,l) /\
                                                                                                               EpochSI(e)=si  /\
         (* ci.id_in = Pred(e) /\ *)
         (* PRF.VerifyData(e,Client,cv) /\ *)
         Authorize(Client,si)}

   | ServerCCSResume        of (ew:succEpoch * (;Id(ew))StatefulLHAE.writer * er:succEpoch * (;Id(er))StatefulLHAE.reader * (;EpochSI(ew))PRF.masterSecret * l:log){EpochSI(ew)=EpochSI(er) /\ ci.id_in = Pred(er) /\ ClientLogBeforeServerFinishedResume(EpochSI(ew),l) /\ Authorize(Client,EpochSI(ew))}
   | ServerFinishedResume   of e:succEpoch * (;Id(e))StatefulLHAE.writer * (;EpochSI(e))PRF.masterSecret * l:log{ClientLogBeforeServerFinishedResume(EpochSI(e),l) /\ Authorize(Client,EpochSI(e))}
   | ClientWritingCCSResume of e:succEpoch * w:(;Id(e))StatefulLHAE.writer * (;EpochSI(e))PRF.masterSecret * sv:sVerifyData * l:log{ClientLogBeforeClientFinishedResume(EpochSI(e),l) /\ (* PRF.VerifyData(e,Server,sv) /\ *)
Authorize(Client,EpochSI(e)) /\
ci.id_out = Pred(e) /\
         StatefulLHAE.History(Id(e),Writer,w) =
         StatefulPlain.EmptyHistory(Id(e)) }
   | ClientWritingFinishedResume of cVerifyData * sVerifyData

   | ClientIdle             of cVerifyData * sVerifyData

type (;ci:ConnectionInfo) protoState = // Cannot use Client and Server, otherwise clashes with Role
  | PSClient of (;ci) clientState
  | PSServer of (;ci) serverState

val clientState: ci:ConnectionInfo -> c:(;ci) clientState -> p:(;ci) protoState{p = PSClient(c)}
val serverState: ci:ConnectionInfo -> c:(;ci) serverState -> p:(;ci) protoState{p = PSServer(c)}

private type (;ci:ConnectionInfo) hs_state = {
  (* I/O buffers *)
  hs_outgoing    : bytes;                  (* outgoing data *)
  hs_incoming    : bytes;                  (* partial incoming HS message *)
  (* local configuration *)
  poptions: config;
  sDB: SessionDB.t;
  (* current handshake & session we are establishing *)
  pstate: (;ci) protoState;
}

(*--- controlinterface *)
(* Control Interface *)

function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
private definition !ci,s. Config(ci,s) = s.poptions

type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

val init:  rl:Role  -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){Config(ci,s) = c /\
                ci.role = rl /\
		IsInitEpoch(ci.id_in) /\
		IsInitEpoch(ci.id_out)}

val resume: nextSID:sessionID -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\
                ci.role = Client /\
		IsInitEpoch(ci.id_in) /\
		IsInitEpoch(ci.id_out)}

val rehandshake: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/
                 (b = false /\ Config(ci,s') = Config(ci,s)))}

val rekey: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	   b:bool * s':(;ci)hs_state{((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s)))}

val request:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
                 b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s)))}

val getPrincipal:  ci:ConnectionInfo -> s:(;ci)hs_state -> string
val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> s':(;ci,Config(ci,s))nextState
(*{SameStreams(ci,s,s')} *)

val getNextEpochs: ci:ConnectionInfo -> si:SessionInfo -> crand -> srand -> ci':ConnectionInfo{
    IsSuccEpoch(ci'.id_in) /\
    IsSuccEpoch(ci'.id_out) /\
    EpochSI(ci'.id_in) = si /\
    EpochSI(ci'.id_out) = si /\
    ci.id_out = Pred(ci'.id_out) /\
    ci.id_in = Pred(ci'.id_in) /\
    ci.role = ci'.role
}

(*--- networkinterface *)
(* Network Interface*)

type (;ci:ConnectionInfo, hs:(;ci) hs_state) outgoing =
  | OutIdle of s':(;ci,Config(ci,hs))nextState
  | OutSome of (rg:range * f:(;Id(ci.id_out),HSFragment.EmptyStream(Id(ci.id_out)),rg)HSFragment.plain * s':(;ci,Config(ci,hs))nextState)
  | OutCCS of  (rg:range * f:(;Id(ci.id_out),HSFragment.EmptyStream(Id(ci.id_out)),rg)HSFragment.plain *
               ci':ConnectionInfo * cs:(;Id(ci'.id_out),Writer)StatefulLHAE.state * s':(;ci',Config(ci,hs))nextState)
               { StatefulLHAE.History(Id(ci'.id_out),Writer,cs) = StatefulPlain.EmptyHistory(Id(ci'.id_out)) /\
                 ci.id_out = Pred(ci'.id_out) /\ IsSuccEpoch(ci'.id_out) /\
                 ci.id_in = ci'.id_in /\
                 ci.role = ci'.role /\
				 ci.id_rand = ci'.id_rand}
  | OutFinished of (rg:range * f:(;Id(ci.id_out),HSFragment.EmptyStream(Id(ci.id_out)),rg)HSFragment.plain * s':(;ci,Config(ci,hs))nextState){
				EvSentFinishedFirst(ci,true)}
  | OutComplete of (rg:range * f:(;Id(ci.id_out),HSFragment.EmptyStream(Id(ci.id_out)),rg)HSFragment.plain * s':(;ci,Config(ci,hs))nextState)
                   {Complete(ci,Config(ci,hs)) /\ EvSentFinishedFirst(ci,false)}
val next_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> (;ci,s)outgoing

type (;ci:ConnectionInfo,c:config)incoming =
  | InAck of (;ci,c)nextState
  | InVersionAgreed  of (;ci,c)nextState * ProtocolVersion
  | InQuery of Cert.chain * advice:bool * (;ci,c)nextState
  | InFinished of (;ci,c)nextState {EvSentFinishedFirst(ci,false)}
  | InComplete of (;ci,c)nextState {Complete(ci,c) /\ EvSentFinishedFirst(ci,true)}
  | InError of alertDescription * string * (;ci,c)nextState
val recv_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;Id(ci.id_in),rg)HSFragment.fragment ->
                   (;ci,Config(ci,s))incoming
val authorize:     ci:ConnectionInfo -> s:(;ci)hs_state ->
                   c:Cert.chain -> (;ci,Config(ci,s))incoming

type (;ci:ConnectionInfo,c:config)incomingCCS =
  | InCCSAck of ci':ConnectionInfo * cs:(;Id(ci'.id_in),Reader)StatefulLHAE.state * (;ci',c)nextState
				{StatefulLHAE.History(Id(ci'.id_in),Reader,cs) = StatefulPlain.EmptyHistory(Id(ci'.id_in)) /\
				ci.id_out = ci'.id_out /\
				ci.id_in = Pred(ci'.id_in) /\ IsSuccEpoch(ci'.id_in) /\
				ci.role = ci'.role /\
				ci.id_rand = ci'.id_rand}
  | InCCSError of alertDescription * string * (;ci,c)nextState
val recv_ccs     : ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;Id(ci.id_in),rg)HSFragment.fragment ->
                   (;ci,Config(ci,s))incomingCCS

function val GetMinVersion: ci:ConnectionInfo * (;ci)hs_state -> ProtocolVersion
private definition !ci,s. GetMinVersion(ci,s) = s.poptions.minVer
val getMinVersion: ci:ConnectionInfo -> s:(;ci)hs_state ->
	pv:ProtocolVersion{pv = GetMinVersion(ci,s)}

(*--- end *)

(* INTERNAL HS VERIFICATION (ALL THESE DEFS ARE PRIVATE) *)

val find_client_cert_sign: certType list -> Sig.alg list -> string list ->
	ProtocolVersion -> Cert.hint -> Cert.sign_cert
val getCertificateBytes: si:SessionInfo ->
  cert_req:(Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
  (b:bytes * cl:Cert.chain){
    (si.client_auth = true /\  B(b) = CertificateMsg(cl)) \/
    (si.client_auth = false /\ B(b) = [||])}

val getCertificateVerifyBytes: si:SessionInfo -> (;si) PRF.masterSecret ->
  cert_req:(Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
  l:log{!cl,a,k. cert_req = Some((cl,a,k)) => Sig.Msg(a,Sig.PK(k),l)} ->
  b:bytes{(!cl,a,k. (cert_req = Some((cl,a,k)) /\ si.client_auth = true) =>
                    (?sign. B(b) = CertificateVerifyMsg(si.protocol_version,a,sign))) /\
          ((cert_req = None \/ si.client_auth = false) => B(b) = [||])}

val prepare_client_output_full_RSA: ci:ConnectionInfo -> (;ci)hs_state ->
	si:SessionInfo -> (Cert.chain * a:Sig.alg * (;a)Sig.skey) option -> l:log ->
	((;ci)hs_state * si':SessionInfo * (;si)PRF.masterSecret * log) Result
val prepare_client_output_full_DHE: ci:ConnectionInfo -> (;ci)hs_state ->
	si:SessionInfo -> (Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
	p:DHGroup.p -> (;p)DHGroup.g -> (;p)DHGroup.elt -> log ->
	((;ci)hs_state * si':SessionInfo * (;si)PRF.masterSecret * log) Result
val on_serverHello_full: ci:ConnectionInfo -> cr:crand -> l:log -> to_log:bytes ->
         (pv:ProtocolVersion * sr:random * sid:sessionID * cs:cipherSuite * cm:Compression * ext:bytes){
         ClientLogBeforeServerHello(cr,l) /\
         to_log = ServerHelloMsg(pv,sr,sid,cs,cm,ext)} ->
 	 (;ci) protoState
val parseMessageState: ci:ConnectionInfo -> hs:(;ci)hs_state ->
	(hs':(;ci)hs_state * ht:HandshakeType * pl:bytes * to_log:bytes{Config(ci,hs) = Config(ci,hs') /\
                                                                     B(to_log) = MessageBytes(ht,B(pl))}) option Result
val recv_fragment_client: ci:ConnectionInfo -> s:(;ci)hs_state -> ProtocolVersion option ->
	(;ci,Config(ci,s))incoming

val prepare_server_output_full_RSA: ci:ConnectionInfo -> s:(;ci)hs_state -> si:SessionInfo ->
	pv:ProtocolVersion -> Sig.alg list -> cVerifyData -> sVerifyData -> l:log{
          ?csid,cs,cm,ex. B(l) = ClientHelloMsg(pv,si.init_crand,csid,cs,cm,ex)
        }->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val prepare_server_output_full_DH: 'a -> 'b -> 'c -> 'd -> res:('e Result){?z. res = Error(z)}
val prepare_server_output_full_DHE: ci:ConnectionInfo -> s:(;ci)hs_state -> SessionInfo ->
	Sig.alg list -> cVerifyData -> sVerifyData -> log ->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val prepare_server_output_full_DH_anon: ci:ConnectionInfo -> s:(;ci)hs_state -> SessionInfo ->
	cVerifyData -> sVerifyData -> log ->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val prepare_server_output_full: ci:ConnectionInfo -> s:(;ci)hs_state -> si:SessionInfo ->
	pv:ProtocolVersion -> cVerifyData -> sVerifyData -> l:log{
          ?csid,cs,cm,ex. B(l) = ClientHelloMsg(pv,si.init_crand,csid,cs,cm,ex)
        } ->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val negotiate: 'a list -> 'a list -> 'a option
val prepare_server_output_resumption: ci:ConnectionInfo -> s:(;ci)hs_state -> crand ->
	si:SessionInfo -> (;si)PRF.masterSecret -> cVerifyData -> sVerifyData -> log ->
	s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}
val startServerFull: ci:ConnectionInfo -> s:(;ci)hs_state ->
  ch:(ProtocolVersion * crand * sessionID * cipherSuites * Compression list * bytes) ->// CHello
  cVerifyData -> sVerifyData ->
  l:log{!pv,cr,sid,cs,cms,ex. ch = (pv,cr,sid,cs,cms,ex) =>
        (?cs',cm'. B(l) = ClientHelloMsg(pv,cr,sid,cs',cm',ex))} ->
  ((s':(;ci)hs_state{Config(ci,s') = Config(ci,s)}) * ProtocolVersion) Result
val recv_fragment_server: ci:ConnectionInfo -> s:(;ci)hs_state -> pv:ProtocolVersion option ->
	(;ci,Config(ci,s))incoming
val enqueue_fragment: ci:ConnectionInfo -> s1:(;ci)hs_state -> bytes -> s2:(;ci)hs_state{Config(ci,s1) = Config(ci,s2)}

val sessionInfoCertBytesAuth: (si:SessionInfo) ->
  (clo: (Cert.chain * a:Sig.alg * (;a)Sig.skey) option) ->
  (si':SessionInfo * b:bytes){
    (si.client_auth = false /\ si' = si /\ B(b) = [||]) \/
    (si.client_auth = true /\ clo = None /\ B(b) = CertificateMsg([]) /\ si = si') \/
    (si.client_auth = true /\  (?cl,a',b'. clo = Some((cl,a',b')) /\ B(b) = CertificateMsg(cl) /\ si'.clientID = cl))}

val certificateVerifyBytesAuth: si:SessionInfo ->
  (;si) PRF.masterSecret ->
  cert_req: (Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
  log:bytes{!cl,a,sk. cert_req = Some((cl,a,sk)) => Sig.Msg(a,Sig.PK(sk),log)} ->
  b:bytes{
    ((si.client_auth = false \/ cert_req = None) /\ B(b) = [||]) \/
     (si.client_auth = true /\
         (?cl,a,sk,sign.
            cert_req = Some((cl,a,sk)) /\
            B(b) = CertificateVerifyMsg(si.protocol_version,a,sign)))}
